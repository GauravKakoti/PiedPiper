use crate::{mod_prelude_sys::*, core};

#[cfg(ocvrs_has_module_calib3d)]
mod calib3d_sys {
	use super::*;

	extern "C" {
		pub fn cv_RQDecomp3x3_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, mtx_r: *const c_void, mtx_q: *const c_void, qx: *const c_void, qy: *const c_void, qz: *const c_void, ocvrs_return: *mut Result<core::Vec3d>);
		pub fn cv_Rodrigues_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, jacobian: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_calibrateCameraRO_const__InputArrayR_const__InputArrayR_Size_int_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, i_fixed_point: i32, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, new_obj_points: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, std_deviations_obj_points: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateCameraRO_const__InputArrayR_const__InputArrayR_Size_int_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, i_fixed_point: i32, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, new_obj_points: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateCamera_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateCamera_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateHandEye_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_HandEyeCalibrationMethod(r_gripper2base: *const c_void, t_gripper2base: *const c_void, r_target2cam: *const c_void, t_target2cam: *const c_void, r_cam2gripper: *const c_void, t_cam2gripper: *const c_void, method: crate::calib3d::HandEyeCalibrationMethod, ocvrs_return: *mut Result_void);
		pub fn cv_calibrateRobotWorldHandEye_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_RobotWorldHandEyeCalibrationMethod(r_world2cam: *const c_void, t_world2cam: *const c_void, r_base2gripper: *const c_void, t_base2gripper: *const c_void, r_base2world: *const c_void, t_base2world: *const c_void, r_gripper2cam: *const c_void, t_gripper2cam: *const c_void, method: crate::calib3d::RobotWorldHandEyeCalibrationMethod, ocvrs_return: *mut Result_void);
		pub fn cv_calibrationMatrixValues_const__InputArrayR_Size_double_double_doubleR_doubleR_doubleR_Point2dR_doubleR(camera_matrix: *const c_void, image_size: *const core::Size, aperture_width: f64, aperture_height: f64, fovx: *mut f64, fovy: *mut f64, focal_length: *mut f64, principal_point: *mut core::Point2d, aspect_ratio: *mut f64, ocvrs_return: *mut Result_void);
		pub fn cv_checkChessboard_const__InputArrayR_Size(img: *const c_void, size: *const core::Size, ocvrs_return: *mut Result<bool>);
		pub fn cv_composeRT_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(rvec1: *const c_void, tvec1: *const c_void, rvec2: *const c_void, tvec2: *const c_void, rvec3: *const c_void, tvec3: *const c_void, dr3dr1: *const c_void, dr3dt1: *const c_void, dr3dr2: *const c_void, dr3dt2: *const c_void, dt3dr1: *const c_void, dt3dt1: *const c_void, dt3dr2: *const c_void, dt3dt2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_computeCorrespondEpilines_const__InputArrayR_int_const__InputArrayR_const__OutputArrayR(points: *const c_void, which_image: i32, f: *const c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_convertPointsFromHomogeneous_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_convertPointsHomogeneous_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_convertPointsToHomogeneous_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_correctMatches_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(f: *const c_void, points1: *const c_void, points2: *const c_void, new_points1: *const c_void, new_points2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_decomposeEssentialMat_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(e: *const c_void, r1: *const c_void, r2: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_decomposeHomographyMat_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(h: *const c_void, k: *const c_void, rotations: *const c_void, translations: *const c_void, normals: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_decomposeProjectionMatrix_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(proj_matrix: *const c_void, camera_matrix: *const c_void, rot_matrix: *const c_void, trans_vect: *const c_void, rot_matrix_x: *const c_void, rot_matrix_y: *const c_void, rot_matrix_z: *const c_void, euler_angles: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_drawChessboardCorners_const__InputOutputArrayR_Size_const__InputArrayR_bool(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, pattern_was_found: bool, ocvrs_return: *mut Result_void);
		pub fn cv_drawFrameAxes_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_float_int(image: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, length: f32, thickness: i32, ocvrs_return: *mut Result_void);
		pub fn cv_estimateAffine2D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(pts1: *const c_void, pts2: *const c_void, inliers: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateAffine2D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_size_t_double_size_t(from: *const c_void, to: *const c_void, inliers: *const c_void, method: i32, ransac_reproj_threshold: f64, max_iters: size_t, confidence: f64, refine_iters: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateAffine3D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, out: *const c_void, inliers: *const c_void, ransac_threshold: f64, confidence: f64, ocvrs_return: *mut Result<i32>);
		pub fn cv_estimateAffine3D_const__InputArrayR_const__InputArrayR_doubleX_bool(src: *const c_void, dst: *const c_void, scale: *mut f64, force_rotation: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateAffinePartial2D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_size_t_double_size_t(from: *const c_void, to: *const c_void, inliers: *const c_void, method: i32, ransac_reproj_threshold: f64, max_iters: size_t, confidence: f64, refine_iters: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateChessboardSharpness_const__InputArrayR_Size_const__InputArrayR_float_bool_const__OutputArrayR(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, rise_distance: f32, vertical: bool, sharpness: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_estimateTranslation3D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, out: *const c_void, inliers: *const c_void, ransac_threshold: f64, confidence: f64, ocvrs_return: *mut Result<i32>);
		pub fn cv_filterHomographyDecompByVisibleRefpoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(rotations: *const c_void, normals: *const c_void, before_points: *const c_void, after_points: *const c_void, possible_solutions: *const c_void, points_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_filterSpeckles_const__InputOutputArrayR_double_int_double_const__InputOutputArrayR(img: *const c_void, new_val: f64, max_speckle_size: i32, max_diff: f64, buf: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_find4QuadCornerSubpix_const__InputArrayR_const__InputOutputArrayR_Size(img: *const c_void, corners: *const c_void, region_size: *const core::Size, ocvrs_return: *mut Result<bool>);
		pub fn cv_findChessboardCornersSB_const__InputArrayR_Size_const__OutputArrayR_int(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_findChessboardCornersSB_const__InputArrayR_Size_const__OutputArrayR_int_const__OutputArrayR(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, flags: i32, meta: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_findChessboardCorners_const__InputArrayR_Size_const__OutputArrayR_int(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_findCirclesGrid_const__InputArrayR_Size_const__OutputArrayR_int_const_PtrLFeature2DGR(image: *const c_void, pattern_size: *const core::Size, centers: *const c_void, flags: i32, blob_detector: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_findCirclesGrid_const__InputArrayR_Size_const__OutputArrayR_int_const_PtrLFeature2DGR_const_CirclesGridFinderParametersR(image: *const c_void, pattern_size: *const core::Size, centers: *const c_void, flags: i32, blob_detector: *const c_void, parameters: *const crate::calib3d::CirclesGridFinderParameters, ocvrs_return: *mut Result<bool>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, camera_matrix2: *const c_void, dist_coeff1: *const c_void, dist_coeff2: *const c_void, mask: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_double_double_int_const__OutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, method: i32, prob: f64, threshold: f64, max_iters: i32, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_double_Point2d_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, focal: f64, pp: *const core::Point2d, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_double_Point2d_int_double_double_int_const__OutputArrayR(points1: *const c_void, points2: *const c_void, focal: f64, pp: *const core::Point2d, method: i32, prob: f64, threshold: f64, max_iters: i32, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(points1: *const c_void, points2: *const c_void, mask: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_double(points1: *const c_void, points2: *const c_void, mask: *const c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_int_double_double_int_const__OutputArrayR(points1: *const c_void, points2: *const c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, max_iters: i32, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findHomography_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(src_points: *const c_void, dst_points: *const c_void, mask: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findHomography_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double(src_points: *const c_void, dst_points: *const c_void, mask: *const c_void, method: i32, ransac_reproj_threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findHomography_const__InputArrayR_const__InputArrayR_int_double_const__OutputArrayR_const_int_const_double(src_points: *const c_void, dst_points: *const c_void, method: i32, ransac_reproj_threshold: f64, mask: *const c_void, max_iters: i32, confidence: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_fisheye_calibrate_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, k: *const c_void, d: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_fisheye_distortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_double(undistorted: *const c_void, distorted: *const c_void, k: *const c_void, d: *const c_void, alpha: f64, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_estimateNewCameraMatrixForUndistortRectify_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputArrayR_const__OutputArrayR_double_const_SizeR_double(k: *const c_void, d: *const c_void, image_size: *const core::Size, r: *const c_void, p: *const c_void, balance: f64, new_size: *const core::Size, fov_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_initUndistortRectifyMap_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_int_const__OutputArrayR_const__OutputArrayR(k: *const c_void, d: *const c_void, r: *const c_void, p: *const c_void, size: *const core::Size, m1type: i32, map1: *const c_void, map2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_projectPoints_const__InputArrayR_const__OutputArrayR_const_Affine3dR_const__InputArrayR_const__InputArrayR_double_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, affine: *const core::Affine3d, k: *const c_void, d: *const c_void, alpha: f64, jacobian: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_projectPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_double_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, rvec: *const c_void, tvec: *const c_void, k: *const c_void, d: *const c_void, alpha: f64, jacobian: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, k1: *const c_void, d1: *const c_void, k2: *const c_void, d2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_fisheye_stereoRectify_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_const_SizeR_double_double(k1: *const c_void, d1: *const c_void, k2: *const c_void, d2: *const c_void, image_size: *const core::Size, r: *const c_void, tvec: *const c_void, r1: *const c_void, r2: *const c_void, p1: *const c_void, p2: *const c_void, q: *const c_void, flags: i32, new_image_size: *const core::Size, balance: f64, fov_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_undistortImage_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, knew: *const c_void, new_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_TermCriteria(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, r: *const c_void, p: *const c_void, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_getDefaultNewCameraMatrix_const__InputArrayR_Size_bool(camera_matrix: *const c_void, imgsize: *const core::Size, center_principal_point: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getOptimalNewCameraMatrix_const__InputArrayR_const__InputArrayR_Size_double_Size_RectX_bool(camera_matrix: *const c_void, dist_coeffs: *const c_void, image_size: *const core::Size, alpha: f64, new_img_size: *const core::Size, valid_pix_roi: *mut core::Rect, center_principal_point: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getValidDisparityROI_Rect_Rect_int_int_int(roi1: *const core::Rect, roi2: *const core::Rect, min_disparity: i32, number_of_disparities: i32, block_size: i32, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_initCameraMatrix2D_const__InputArrayR_const__InputArrayR_Size_double(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, aspect_ratio: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_initInverseRectificationMap_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_int_const__OutputArrayR_const__OutputArrayR(camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, new_camera_matrix: *const c_void, size: *const core::Size, m1type: i32, map1: *const c_void, map2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_initUndistortRectifyMap_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_int_const__OutputArrayR_const__OutputArrayR(camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, new_camera_matrix: *const c_void, size: *const core::Size, m1type: i32, map1: *const c_void, map2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_initWideAngleProjMap_const__InputArrayR_const__InputArrayR_Size_int_int_const__OutputArrayR_const__OutputArrayR_UndistortTypes_double(camera_matrix: *const c_void, dist_coeffs: *const c_void, image_size: *const core::Size, dest_image_width: i32, m1type: i32, map1: *const c_void, map2: *const c_void, proj_type: crate::calib3d::UndistortTypes, alpha: f64, ocvrs_return: *mut Result<f32>);
		pub fn cv_matMulDeriv_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(a: *const c_void, b: *const c_void, d_a_bd_a: *const c_void, d_a_bd_b: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_projectPoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double(object_points: *const c_void, rvec: *const c_void, tvec: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, image_points: *const c_void, jacobian: *const c_void, aspect_ratio: f64, ocvrs_return: *mut Result_void);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_double_double_const__InputOutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, e: *const c_void, r: *const c_void, t: *const c_void, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, r: *const c_void, t: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_const__InputOutputArrayR_const__OutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, r: *const c_void, t: *const c_void, distance_thresh: f64, mask: *const c_void, triangulated_points: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_Point2d_const__InputOutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, r: *const c_void, t: *const c_void, focal: f64, pp: *const core::Point2d, mask: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rectify3Collinear_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_double_Size_RectX_RectX_int(camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, camera_matrix3: *const c_void, dist_coeffs3: *const c_void, imgpt1: *const c_void, imgpt3: *const c_void, image_size: *const core::Size, r12: *const c_void, t12: *const c_void, r13: *const c_void, t13: *const c_void, r1: *const c_void, r2: *const c_void, r3: *const c_void, p1: *const c_void, p2: *const c_void, p3: *const c_void, q: *const c_void, alpha: f64, new_img_size: *const core::Size, roi1: *mut core::Rect, roi2: *mut core::Rect, flags: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_reprojectImageTo3D_const__InputArrayR_const__OutputArrayR_const__InputArrayR_bool_int(disparity: *const c_void, _3d_image: *const c_void, q: *const c_void, handle_missing_values: bool, ddepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_sampsonDistance_const__InputArrayR_const__InputArrayR_const__InputArrayR(pt1: *const c_void, pt2: *const c_void, f: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_solveP3P_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_solvePnPGeneric_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_SolvePnPMethod_const__InputArrayR_const__InputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, use_extrinsic_guess: bool, flags: crate::calib3d::SolvePnPMethod, rvec: *const c_void, tvec: *const c_void, reprojection_error: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_solvePnPRansac_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_int_float_double_const__OutputArrayR_int(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, confidence: f64, inliers: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_solvePnPRansac_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const_UsacParamsR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, inliers: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<bool>);
		pub fn cv_solvePnPRefineLM_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_TermCriteria(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_solvePnPRefineVVS_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_TermCriteria_double(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, criteria: *const core::TermCriteria, vv_slambda: f64, ocvrs_return: *mut Result_void);
		pub fn cv_solvePnP_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_int(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, e: *const c_void, f: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, e: *const c_void, f: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_stereoRectifyUncalibrated_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__OutputArrayR_const__OutputArrayR_double(points1: *const c_void, points2: *const c_void, f: *const c_void, img_size: *const core::Size, h1: *const c_void, h2: *const c_void, threshold: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_stereoRectify_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_double_Size_RectX_RectX(camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, r1: *const c_void, r2: *const c_void, p1: *const c_void, p2: *const c_void, q: *const c_void, flags: i32, alpha: f64, new_image_size: *const core::Size, valid_pix_roi1: *mut core::Rect, valid_pix_roi2: *mut core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_triangulatePoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(proj_matr1: *const c_void, proj_matr2: *const c_void, proj_points1: *const c_void, proj_points2: *const c_void, points4_d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_undistortImagePoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_TermCriteria(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, unnamed: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, p: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_TermCriteria(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, p: *const c_void, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_undistort_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, new_camera_matrix: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_validateDisparity_const__InputOutputArrayR_const__InputArrayR_int_int_int(disparity: *const c_void, cost: *const c_void, min_disparity: i32, number_of_disparities: i32, disp12_max_disp: i32, ocvrs_return: *mut Result_void);
		pub fn cv_CirclesGridFinderParameters_CirclesGridFinderParameters(ocvrs_return: *mut Result<crate::calib3d::CirclesGridFinderParameters>);
		pub fn cv_LMSolver_run_const_const__InputOutputArrayR(instance: *const c_void, param: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_LMSolver_setMaxIters_int(instance: *mut c_void, max_iters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_LMSolver_getMaxIters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_LMSolver_create_const_PtrLCallbackGR_int(cb: *const c_void, max_iters: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LMSolver_create_const_PtrLCallbackGR_int_double(cb: *const c_void, max_iters: i32, eps: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LMSolver_Callback_compute_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, param: *const c_void, err: *const c_void, j: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_StereoBM_getPreFilterType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setPreFilterType_int(instance: *mut c_void, pre_filter_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getPreFilterSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setPreFilterSize_int(instance: *mut c_void, pre_filter_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getPreFilterCap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setPreFilterCap_int(instance: *mut c_void, pre_filter_cap: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getTextureThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setTextureThreshold_int(instance: *mut c_void, texture_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getUniquenessRatio_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setUniquenessRatio_int(instance: *mut c_void, uniqueness_ratio: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getSmallerBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setSmallerBlockSize_int(instance: *mut c_void, block_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getROI1_const(instance: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_StereoBM_setROI1_Rect(instance: *mut c_void, roi1: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getROI2_const(instance: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_StereoBM_setROI2_Rect(instance: *mut c_void, roi2: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_create_int_int(num_disparities: i32, block_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_StereoMatcher_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, left: *const c_void, right: *const c_void, disparity: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getMinDisparity_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setMinDisparity_int(instance: *mut c_void, min_disparity: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getNumDisparities_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setNumDisparities_int(instance: *mut c_void, num_disparities: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setBlockSize_int(instance: *mut c_void, block_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getSpeckleWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setSpeckleWindowSize_int(instance: *mut c_void, speckle_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getSpeckleRange_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setSpeckleRange_int(instance: *mut c_void, speckle_range: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getDisp12MaxDiff_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setDisp12MaxDiff_int(instance: *mut c_void, disp12_max_diff: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_getPreFilterCap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoSGBM_setPreFilterCap_int(instance: *mut c_void, pre_filter_cap: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_getUniquenessRatio_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoSGBM_setUniquenessRatio_int(instance: *mut c_void, uniqueness_ratio: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_getP1_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoSGBM_setP1_int(instance: *mut c_void, p1: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_getP2_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoSGBM_setP2_int(instance: *mut c_void, p2: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_getMode_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoSGBM_setMode_int(instance: *mut c_void, mode: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_create_int_int_int_int_int_int_int_int_int_int_int(min_disparity: i32, num_disparities: i32, block_size: i32, p1: i32, p2: i32, disp12_max_diff: i32, pre_filter_cap: i32, uniqueness_ratio: i32, speckle_window_size: i32, speckle_range: i32, mode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UsacParams_UsacParams(ocvrs_return: *mut Result<crate::calib3d::UsacParams>);
	}
}
#[cfg(ocvrs_has_module_calib3d)]
pub use calib3d_sys::*;

#[cfg(ocvrs_has_module_core)]
mod core_sys {
	use super::*;

	extern "C" {
		pub fn cv_Cholesky_doubleX_size_t_int_doubleX_size_t_int(a: *mut f64, astep: size_t, m: i32, b: *mut f64, bstep: size_t, n: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_Cholesky_floatX_size_t_int_floatX_size_t_int(a: *mut f32, astep: size_t, m: i32, b: *mut f32, bstep: size_t, n: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_LUT_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, lut: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LU_doubleX_size_t_int_doubleX_size_t_int(a: *mut f64, astep: size_t, m: i32, b: *mut f64, bstep: size_t, n: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_LU_floatX_size_t_int_floatX_size_t_int(a: *mut f32, astep: size_t, m: i32, b: *mut f32, bstep: size_t, n: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Mahalanobis_const__InputArrayR_const__InputArrayR_const__InputArrayR(v1: *const c_void, v2: *const c_void, icovar: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_PCABackProject_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_double(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, eigenvalues: *const c_void, retained_variance: f64, ocvrs_return: *mut Result_void);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, eigenvalues: *const c_void, max_components: i32, ocvrs_return: *mut Result_void);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_double(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, retained_variance: f64, ocvrs_return: *mut Result_void);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_int(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, max_components: i32, ocvrs_return: *mut Result_void);
		pub fn cv_PCAProject_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PSNR_const__InputArrayR_const__InputArrayR_double(src1: *const c_void, src2: *const c_void, r: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_SVBackSubst_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(w: *const c_void, u: *const c_void, vt: *const c_void, rhs: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SVDecomp_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int(src: *const c_void, w: *const c_void, u: *const c_void, vt: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_abs_const_MatExprR(e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_abs_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_absdiff_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_addWeighted_const__InputArrayR_double_const__InputArrayR_double_double_const__OutputArrayR_int(src1: *const c_void, alpha: f64, src2: *const c_void, beta: f64, gamma: f64, dst: *const c_void, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_add_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_batchDistance_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_const__OutputArrayR_int_int_const__InputArrayR_int_bool(src1: *const c_void, src2: *const c_void, dist: *const c_void, dtype: i32, nidx: *const c_void, norm_type: i32, k: i32, mask: *const c_void, update: i32, crosscheck: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_and_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_not_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_or_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_xor_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_borderInterpolate_int_int_int(p: i32, len: i32, border_type: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_calcCovarMatrix_const__InputArrayR_const__OutputArrayR_const__InputOutputArrayR_int_int(samples: *const c_void, covar: *const c_void, mean: *const c_void, flags: i32, ctype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cartToPolar_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool(x: *const c_void, y: *const c_void, magnitude: *const c_void, angle: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result_void);
		pub fn cv_checkHardwareSupport_int(feature: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_checkRange_const__InputArrayR_bool_PointX_double_double(a: *const c_void, quiet: bool, pos: *mut core::Point, min_val: f64, max_val: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_compare_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, cmpop: i32, ocvrs_return: *mut Result_void);
		pub fn cv_completeSymm_const__InputOutputArrayR_bool(m: *const c_void, lower_to_upper: bool, ocvrs_return: *mut Result_void);
		pub fn cv_convertFp16_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_convertScaleAbs_const__InputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, alpha: f64, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_copyMakeBorder_const__InputArrayR_const__OutputArrayR_int_int_int_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, top: i32, bottom: i32, left: i32, right: i32, border_type: i32, value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_copyTo_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_countNonZero_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cubeRoot_float(val: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_cuda_createContinuous_int_int_int_const__OutputArrayR(rows: i32, cols: i32, typ: i32, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_deviceSupports_FeatureSet(feature_set: core::FeatureSet, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_ensureSizeIsEnough_int_int_int_const__OutputArrayR(rows: i32, cols: i32, typ: i32, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_getCudaEnabledDeviceCount(ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_getDevice(ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_printCudaDeviceInfo_int(device: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_printShortCudaDeviceInfo_int(device: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_registerPageLocked_MatR(m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_resetDevice(ocvrs_return: *mut Result_void);
		pub fn cv_cuda_setBufferPoolConfig_int_size_t_int(device_id: i32, stack_size: size_t, stack_count: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_setBufferPoolUsage_bool(on: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_setDevice_int(device: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_setGlDevice_int(device: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_unregisterPageLocked_MatR(m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dct_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_depthToString_int(depth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_check_failed_MatChannels_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_MatChannels_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_MatDepth_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_MatDepth_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_MatType_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_MatType_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_Size_LintG_const_CheckContextR(v: *const core::Size_<i32>, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_Size_LintG_const_Size_LintG_const_CheckContextR(v1: *const core::Size_<i32>, v2: *const core::Size_<i32>, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_double_const_CheckContextR(v: f64, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_double_const_double_const_CheckContextR(v1: f64, v2: f64, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_float_const_CheckContextR(v: f32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_float_const_float_const_CheckContextR(v1: f32, v2: f32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_size_t_const_CheckContextR(v: size_t, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_size_t_const_size_t_const_CheckContextR(v1: size_t, v2: size_t, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_stringR_const_CheckContextR(v1: *const c_char, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_determinant_const__InputArrayR(mtx: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_dft_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, flags: i32, nonzero_rows: i32, ocvrs_return: *mut Result_void);
		pub fn cv_directx_getTypeFromD3DFORMAT_const_int(i_d3_dformat: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_directx_getTypeFromDXGI_FORMAT_const_int(i_dxgi_format: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_divide_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, scale: f64, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_divide_double_const__InputArrayR_const__OutputArrayR_int(scale: f64, src2: *const c_void, dst: *const c_void, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_eigenNonSymmetric_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, eigenvalues: *const c_void, eigenvectors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_eigen_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, eigenvalues: *const c_void, eigenvectors: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_error_const_ExceptionR(exc: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_error_int_const_StringR_const_charX_const_charX_int(_code: i32, _err: *const c_char, _func: *const c_char, _file: *const c_char, _line: i32, ocvrs_return: *mut Result_void);
		pub fn cv_exp_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_extractChannel_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, coi: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastAtan2_float_float(y: f32, x: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_findNonZero_const__InputArrayR_const__OutputArrayR(src: *const c_void, idx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_flip_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flip_code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_gemm_const__InputArrayR_const__InputArrayR_double_const__InputArrayR_double_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, alpha: f64, src3: *const c_void, beta: f64, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_getBuildInformation(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getCPUFeaturesLine(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getCPUTickCount(ocvrs_return: *mut Result<i64>);
		pub fn cv_getElemSize_int(typ: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_getHardwareFeatureName_int(feature: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getLogLevel(ocvrs_return: *mut Result<i32>);
		pub fn cv_getNumThreads(ocvrs_return: *mut Result<i32>);
		pub fn cv_getNumberOfCPUs(ocvrs_return: *mut Result<i32>);
		pub fn cv_getOptimalDFTSize_int(vecsize: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getThreadNum(ocvrs_return: *mut Result<i32>);
		pub fn cv_getTickCount(ocvrs_return: *mut Result<i64>);
		pub fn cv_getTickFrequency(ocvrs_return: *mut Result<f64>);
		pub fn cv_getVersionMajor() -> i32;
		pub fn cv_getVersionMinor() -> i32;
		pub fn cv_getVersionRevision() -> i32;
		pub fn cv_getVersionString(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_glob_String_vectorLStringGR_bool(pattern: *mut c_char, result: *mut c_void, recursive: bool, ocvrs_return: *mut Result_void);
		pub fn cv_haveOpenVX(ocvrs_return: *mut Result<bool>);
		pub fn cv_hconcat_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hconcat_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_idct_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_idft_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, flags: i32, nonzero_rows: i32, ocvrs_return: *mut Result_void);
		pub fn cv_inRange_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, lowerb: *const c_void, upperb: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_insertChannel_const__InputArrayR_const__InputOutputArrayR_int(src: *const c_void, dst: *const c_void, coi: i32, ocvrs_return: *mut Result_void);
		pub fn cv_instr_getFlags(ocvrs_return: *mut Result<core::FLAGS>);
		pub fn cv_instr_resetTrace(ocvrs_return: *mut Result_void);
		pub fn cv_instr_setFlags_FLAGS(mode_flags: core::FLAGS, ocvrs_return: *mut Result_void);
		pub fn cv_instr_setUseInstrumentation_bool(flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_instr_useInstrumentation(ocvrs_return: *mut Result<bool>);
		pub fn cv_invert_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_ipp_getIppErrorLocation(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ipp_getIppFeatures(ocvrs_return: *mut Result<u64>);
		pub fn cv_ipp_getIppStatus(ocvrs_return: *mut Result<i32>);
		pub fn cv_ipp_getIppVersion(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ipp_setIppStatus_int_const_charX_const_charX_int(status: i32, funcname: *const c_char, filename: *const c_char, line: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ipp_setUseIPP_NotExact_bool(flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ipp_setUseIPP_bool(flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ipp_useIPP(ocvrs_return: *mut Result<bool>);
		pub fn cv_ipp_useIPP_NotExact(ocvrs_return: *mut Result<bool>);
		pub fn cv_kmeans_const__InputArrayR_int_const__InputOutputArrayR_TermCriteria_int_int_const__OutputArrayR(data: *const c_void, k: i32, best_labels: *const c_void, criteria: *const core::TermCriteria, attempts: i32, flags: i32, centers: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_log_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_magnitude_const__InputArrayR_const__InputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, magnitude: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_max_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_max_const_MatR_const_MatR_MatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_max_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_max_const_UMatR_const_UMatR_UMatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_max_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_max_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_meanStdDev_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, mean: *const c_void, stddev: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_mean_const__InputArrayR_const__InputArrayR(src: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_merge_const__InputArrayR_const__OutputArrayR(mv: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_minMaxIdx_const__InputArrayR_doubleX_doubleX_intX_intX_const__InputArrayR(src: *const c_void, min_val: *mut f64, max_val: *mut f64, min_idx: *mut i32, max_idx: *mut i32, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_minMaxLoc_const_SparseMatR_doubleX_doubleX_intX_intX(a: *const c_void, min_val: *mut f64, max_val: *mut f64, min_idx: *mut i32, max_idx: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_minMaxLoc_const__InputArrayR_doubleX_doubleX_PointX_PointX_const__InputArrayR(src: *const c_void, min_val: *mut f64, max_val: *mut f64, min_loc: *mut core::Point, max_loc: *mut core::Point, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_min_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_min_const_MatR_const_MatR_MatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_min_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_min_const_UMatR_const_UMatR_UMatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_min_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_min_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mixChannels_const__InputArrayR_const__InputOutputArrayR_const_intX_size_t(src: *const c_void, dst: *const c_void, from_to: *const i32, npairs: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_mixChannels_const__InputArrayR_const__InputOutputArrayR_const_vectorLintGR(src: *const c_void, dst: *const c_void, from_to: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_mulSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_bool(a: *const c_void, b: *const c_void, c: *const c_void, flags: i32, conj_b: bool, ocvrs_return: *mut Result_void);
		pub fn cv_mulTransposed_const__InputArrayR_const__OutputArrayR_bool_const__InputArrayR_double_int(src: *const c_void, dst: *const c_void, a_ta: bool, delta: *const c_void, scale: f64, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_multiply_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, scale: f64, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_noArray() -> *mut c_void;
		pub fn cv_norm_const_SparseMatR_int(src: *const c_void, norm_type: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_norm_const__InputArrayR_const__InputArrayR_int_const__InputArrayR(src1: *const c_void, src2: *const c_void, norm_type: i32, mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_norm_const__InputArrayR_int_const__InputArrayR(src1: *const c_void, norm_type: i32, mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_normalize_const_SparseMatR_SparseMatR_double_int(src: *const c_void, dst: *mut c_void, alpha: f64, norm_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_normalize_const__InputArrayR_const__InputOutputArrayR_double_double_int_int_const__InputArrayR(src: *const c_void, dst: *const c_void, alpha: f64, beta: f64, norm_type: i32, dtype: i32, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_attachContext_const_StringR_voidX_voidX_voidX(platform_name: *const c_char, platform_id: *mut c_void, context: *mut c_void, device_id: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_buildOptionsAddMatrixDescription_StringR_const_StringR_const__InputArrayR(build_options: *mut *mut c_void, name: *const c_char, _m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_checkOptimalVectorWidth_const_intX_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_OclVectorStrategy(vector_widths: *const i32, src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, src5: *const c_void, src6: *const c_void, src7: *const c_void, src8: *const c_void, src9: *const c_void, strat: core::OclVectorStrategy, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_convertFromBuffer_voidX_size_t_int_int_int_UMatR(cl_mem_buffer: *mut c_void, step: size_t, rows: i32, cols: i32, typ: i32, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_convertFromImage_voidX_UMatR(cl_mem_image: *mut c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_convertTypeStr_int_int_int_charX(sdepth: i32, ddepth: i32, cn: i32, buf: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_finish(ocvrs_return: *mut Result_void);
		pub fn cv_ocl_getOpenCLErrorString_int(error_code: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_getPlatfomsInfo_vectorLPlatformInfoGR(platform_info: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_haveAmdBlas(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_haveAmdFft(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_haveOpenCL(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_haveSVM(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_kernelToStr_const__InputArrayR_int_const_charX(_kernel: *const c_void, ddepth: i32, name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_memopTypeToStr_int(t: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_predictOptimalVectorWidthMax_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, src5: *const c_void, src6: *const c_void, src7: *const c_void, src8: *const c_void, src9: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_predictOptimalVectorWidth_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_OclVectorStrategy(src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, src5: *const c_void, src6: *const c_void, src7: *const c_void, src8: *const c_void, src9: *const c_void, strat: core::OclVectorStrategy, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_setUseOpenCL_bool(flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_typeToStr_int(t: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_useOpenCL(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_vecopTypeToStr_int(t: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_convertFromGLTexture2D_const_Texture2DR_const__OutputArrayR(texture: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_convertToGLTexture2D_const__InputArrayR_Texture2DR(src: *const c_void, texture: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_mapGLBuffer_const_BufferR_AccessFlag(buffer: *const c_void, access_flags: core::AccessFlag, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_ocl_initializeContextFromGL(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_render_const_ArraysR_const__InputArrayR_int_Scalar(arr: *const c_void, indices: *const c_void, mode: i32, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_render_const_ArraysR_int_Scalar(arr: *const c_void, mode: i32, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_render_const_Texture2DR_Rect_LdoubleG_Rect_LdoubleG(tex: *const c_void, wnd_rect: *const core::Rect_<f64>, tex_rect: *const core::Rect_<f64>, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_unmapGLBuffer_UMatR(u: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_operatorA_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatExprR_const_ScalarR(e: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_ScalarR_const_MatExprR(s: *const core::Scalar, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatExprR_double(e: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_double_const_MatExprR(s: f64, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_FileNodeIteratorR_const_FileNodeIteratorR(it1: *const c_void, it2: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_operatorEQ_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_FileNodeIteratorR_const_FileNodeIteratorR(it1: *const c_void, it2: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_operatorNE_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNOTB_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR(e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR_const_ScalarR(e: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_ScalarR_const_MatExprR(s: *const core::Scalar, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatExprR_double(e: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_double_const_MatExprR(s: f64, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_parallel_for__const_RangeR_const_ParallelLoopBodyR_double(range: *const c_void, body: *const c_void, nstripes: f64, ocvrs_return: *mut Result_void);
		pub fn cv_patchNaNs_const__InputOutputArrayR_double(a: *const c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_perspectiveTransform_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_phase_const__InputArrayR_const__InputArrayR_const__OutputArrayR_bool(x: *const c_void, y: *const c_void, angle: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result_void);
		pub fn cv_polarToCart_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool(magnitude: *const c_void, angle: *const c_void, x: *const c_void, y: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result_void);
		pub fn cv_pow_const__InputArrayR_double_const__OutputArrayR(src: *const c_void, power: f64, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randShuffle_const__InputOutputArrayR_double_RNGX(dst: *const c_void, iter_factor: f64, rng: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randn_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR(dst: *const c_void, mean: *const c_void, stddev: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randu_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR(dst: *const c_void, low: *const c_void, high: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_DMatchR_const_DMatchR(node: *const c_void, value: *mut core::DMatch, default_value: *const core::DMatch, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_KeyPointR_const_KeyPointR(node: *const c_void, value: *mut c_void, default_value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_MatR_const_MatR(node: *const c_void, mat: *mut c_void, default_mat: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_SparseMatR_const_SparseMatR(node: *const c_void, mat: *mut c_void, default_mat: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_doubleR_double(node: *const c_void, value: *mut f64, default_value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_floatR_float(node: *const c_void, value: *mut f32, default_value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_intR_int(node: *const c_void, value: *mut i32, default_value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_stringR_const_stringR(node: *const c_void, value: *mut *mut c_void, default_value: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_vectorLDMatchGR(node: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_vectorLKeyPointGR(node: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_reduceArgMax_const__InputArrayR_const__OutputArrayR_int_bool(src: *const c_void, dst: *const c_void, axis: i32, last_index: bool, ocvrs_return: *mut Result_void);
		pub fn cv_reduceArgMin_const__InputArrayR_const__OutputArrayR_int_bool(src: *const c_void, dst: *const c_void, axis: i32, last_index: bool, ocvrs_return: *mut Result_void);
		pub fn cv_reduce_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, dim: i32, rtype: i32, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_repeat_const_MatR_int_int(src: *const c_void, ny: i32, nx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_repeat_const__InputArrayR_int_int_const__OutputArrayR(src: *const c_void, ny: i32, nx: i32, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rotate_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, rotate_code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_samples_addSamplesDataSearchPath_const_StringR(path: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_samples_addSamplesDataSearchSubDirectory_const_StringR(subdir: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_samples_findFileOrKeep_const_StringR_bool(relative_path: *const c_char, silent_mode: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_samples_findFile_const_StringR_bool_bool(relative_path: *const c_char, required: bool, silent_mode: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_scaleAdd_const__InputArrayR_double_const__InputArrayR_const__OutputArrayR(src1: *const c_void, alpha: f64, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_setBreakOnError_bool(flag: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_setIdentity_const__InputOutputArrayR_const_ScalarR(mtx: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_setLogLevel_int(level: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_setNumThreads_int(nthreads: i32, ocvrs_return: *mut Result_void);
		pub fn cv_setRNGSeed_int(seed: i32, ocvrs_return: *mut Result_void);
		pub fn cv_setUseOpenVX_bool(flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_setUseOptimized_bool(onoff: bool, ocvrs_return: *mut Result_void);
		pub fn cv_solveCubic_const__InputArrayR_const__OutputArrayR(coeffs: *const c_void, roots: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_solveLP_const__InputArrayR_const__InputArrayR_const__OutputArrayR(func: *const c_void, constr: *const c_void, z: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_solvePoly_const__InputArrayR_const__OutputArrayR_int(coeffs: *const c_void, roots: *const c_void, max_iters: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_solve_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_sortIdx_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_sort_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_split_const_MatR_MatX(src: *const c_void, mvbegin: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_split_const__InputArrayR_const__OutputArrayR(m: *const c_void, mv: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sqrt_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_subtract_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_sum_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_swap_MatR_MatR(a: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_swap_UMatR_UMatR(a: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_tempfile_const_charX(suffix: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_theRNG(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_trace_const__InputArrayR(mtx: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_transform_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_transposeND_const__InputArrayR_const_vectorLintGR_const__OutputArrayR(src: *const c_void, order: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_transpose_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_typeToString_int(typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_useOpenVX(ocvrs_return: *mut Result<bool>);
		pub fn cv_useOptimized(ocvrs_return: *mut Result<bool>);
		pub fn cv_utils_dumpBool_bool(argument: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpCString_const_charX(argument: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpDouble_double(argument: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpFloat_float(argument: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputArrayOfArrays_const__InputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputArray_const__InputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputOutputArrayOfArrays_const__InputOutputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputOutputArray_const__InputOutputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInt_int(argument: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpRange_const_RangeR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpRect_const_RectR(argument: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpRotatedRect_const_RotatedRectR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpSizeT_size_t(argument: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpString_const_StringR(argument: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpTermCriteria_const_TermCriteriaR(argument: *const core::TermCriteria, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVectorOfDouble_const_vectorLdoubleGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVectorOfInt_const_vectorLintGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVectorOfRect_const_vectorLRectGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_fs_getCacheDirectoryForDownloads(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_generateVectorOfInt_size_t_vectorLintGR(len: size_t, vec: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_utils_generateVectorOfMat_size_t_int_int_int_vectorLMatGR(len: size_t, rows: i32, cols: i32, dtype: i32, vec: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_utils_generateVectorOfRect_size_t_vectorLRectGR(len: size_t, vec: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_utils_getThreadID(ocvrs_return: *mut Result<i32>);
		pub fn cv_utils_logging_getLogLevel(ocvrs_return: *mut Result<core::LogLevel>);
		pub fn cv_utils_logging_getLogTagLevel_const_charX(tag: *const c_char, ocvrs_return: *mut Result<core::LogLevel>);
		pub fn cv_utils_logging_internal_getGlobalLogTag(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_logging_internal_writeLogMessageEx_LogLevel_const_charX_const_charX_int_const_charX_const_charX(log_level: core::LogLevel, tag: *const c_char, file: *const c_char, line: i32, func: *const c_char, message: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_utils_logging_internal_writeLogMessage_LogLevel_const_charX(log_level: core::LogLevel, message: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_utils_logging_registerLogTag_LogTagX(plogtag: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_utils_logging_setLogLevel_LogLevel(log_level: core::LogLevel, ocvrs_return: *mut Result<core::LogLevel>);
		pub fn cv_utils_logging_setLogTagLevel_const_charX_LogLevel(tag: *const c_char, level: core::LogLevel, ocvrs_return: *mut Result_void);
		pub fn cv_utils_nested_testEchoBooleanFunction_bool(flag: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_utils_testAsyncArray_const__InputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testAsyncException(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverloadResolution_const_RectR(rect: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverloadResolution_int_const_PointR(value: i32, point: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverwriteNativeMethod_int(argument: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_utils_testRaiseGeneralException(ocvrs_return: *mut Result_void);
		pub fn cv_utils_testReservedKeywordConversion_int_int_int(positional_argument: i32, lambda: i32, from: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testRotatedRectVector_float_float_float_float_float(x: f32, y: f32, w: f32, h: f32, angle: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testRotatedRect_float_float_float_float_float(x: f32, y: f32, w: f32, h: f32, angle: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_va_intel_convertFromVASurface_VADisplay_VASurfaceID_Size_const__OutputArrayR(display: *mut c_void, surface: core::va_surface_id, size: *const core::Size, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_va_intel_convertToVASurface_VADisplay_const__InputArrayR_VASurfaceID_Size(display: *mut c_void, src: *const c_void, surface: core::va_surface_id, size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_va_intel_ocl_initializeContextFromVA_VADisplay_bool(display: *mut c_void, try_interop: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_vconcat_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_vconcat_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_writeScalar_FileStorageR_const_StringR(fs: *mut c_void, value: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_writeScalar_FileStorageR_double(fs: *mut c_void, value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_writeScalar_FileStorageR_float(fs: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_writeScalar_FileStorageR_int(fs: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_MatR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_SparseMatR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_StringR(fs: *mut c_void, name: *const c_char, value: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_vectorLDMatchGR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_vectorLKeyPointGR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_double(fs: *mut c_void, name: *const c_char, value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_float(fs: *mut c_void, name: *const c_char, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_int(fs: *mut c_void, name: *const c_char, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_Algorithm(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Algorithm_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_write_const_const_PtrLFileStorageGR_const_StringR(instance: *const c_void, fs: *const c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Algorithm_save_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AsyncArray_AsyncArray() -> *mut c_void;
		pub fn cv_AsyncArray_AsyncArray_const_AsyncArrayR(o: *const c_void) -> *mut c_void;
		pub fn cv_AsyncArray_release(instance: *mut c_void);
		pub fn cv_AsyncArray_get_const_const__OutputArrayR(instance: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AsyncArray_get_const_const__OutputArrayR_int64_t(instance: *const c_void, dst: *const c_void, timeout_ns: i64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_get_const_const__OutputArrayR_double(instance: *const c_void, dst: *const c_void, timeout_ns: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_wait_for_const_int64_t(instance: *const c_void, timeout_ns: i64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_wait_for_const_double(instance: *const c_void, timeout_ns: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_valid_const(instance: *const c_void) -> bool;
		pub fn cv_AsyncArray_AsyncArray_AsyncArrayRR(o: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AsyncPromise_AsyncPromise() -> *mut c_void;
		pub fn cv_AsyncPromise_AsyncPromise_const_AsyncPromiseR(o: *const c_void) -> *mut c_void;
		pub fn cv_AsyncPromise_release(instance: *mut c_void);
		pub fn cv_AsyncPromise_getArrayResult(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AsyncPromise_setValue_const__InputArrayR(instance: *mut c_void, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AsyncPromise_setException_const_ExceptionR(instance: *mut c_void, exception: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AsyncPromise_AsyncPromise_AsyncPromiseRR(o: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AsyncPromise__getImpl_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_CommandLineParser_CommandLineParser_int_const_charXX_const_StringR(argc: i32, argv: *const *const c_char, keys: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_CommandLineParser_const_CommandLineParserR(parser: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_getPathToApplication_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_has_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_check_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_about_const_StringR(instance: *mut c_void, message: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_CommandLineParser_printMessage_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CommandLineParser_printErrors_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ConjGradSolver_create_const_PtrLFunctionGR_TermCriteria(f: *const c_void, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DMatch_DMatch(ocvrs_return: *mut Result<core::DMatch>);
		pub fn cv_DMatch_DMatch_int_int_float(_query_idx: i32, _train_idx: i32, _distance: f32, ocvrs_return: *mut Result<core::DMatch>);
		pub fn cv_DMatch_DMatch_int_int_int_float(_query_idx: i32, _train_idx: i32, _img_idx: i32, _distance: f32, ocvrs_return: *mut Result<core::DMatch>);
		pub fn cv_DMatch_operatorL_const_const_DMatchR(instance: *const core::DMatch, m: *const core::DMatch, ocvrs_return: *mut Result<bool>);
		pub fn cv_DownhillSolver_getInitStep_const_const__OutputArrayR(instance: *const c_void, step: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DownhillSolver_setInitStep_const__InputArrayR(instance: *mut c_void, step: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DownhillSolver_create_const_PtrLFunctionGR_const__InputArrayR_TermCriteria(f: *const c_void, init_step: *const c_void, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Exception_getPropMsg_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_setPropMsg_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_Exception_getPropCode_const(instance: *const c_void) -> i32;
		pub fn cv_Exception_setPropCode_int(instance: *mut c_void, val: i32);
		pub fn cv_Exception_getPropErr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_setPropErr_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_Exception_getPropFunc_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_setPropFunc_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_Exception_getPropFile_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_setPropFile_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_Exception_getPropLine_const(instance: *const c_void) -> i32;
		pub fn cv_Exception_setPropLine_int(instance: *mut c_void, val: i32);
		pub fn cv_Exception_Exception(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Exception_Exception_int_const_StringR_const_StringR_const_StringR_int(_code: i32, _err: *const c_char, _func: *const c_char, _file: *const c_char, _line: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Exception_what_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Exception_formatMessage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileNode_getPropBlockIdx_const(instance: *const c_void) -> size_t;
		pub fn cv_FileNode_setPropBlockIdx_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_FileNode_getPropOfs_const(instance: *const c_void) -> size_t;
		pub fn cv_FileNode_setPropOfs_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_FileNode_FileNode(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_FileNode_const_FileStorageX_size_t_size_t(fs: *const c_void, block_idx: size_t, ofs: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_FileNode_const_FileNodeR(node: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_operator___const_const_StringR(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_operator___const_const_charX(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_operator___const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_keys_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FileNode_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isNone_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isSeq_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isMap_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isInt_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isReal_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isString_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isNamed_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_size_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_FileNode_rawSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_FileNode_operator_int_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FileNode_operator_float_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_FileNode_operator_double_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FileNode_operator_std_string_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_isMap_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isSeq_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isCollection_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isEmptyCollection_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isFlow_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_ptr(instance: *mut c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_FileNode_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_FileNode_begin_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_end_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_readRaw_const_const_StringR_voidX_size_t(instance: *const c_void, fmt: *const c_char, vec: *mut c_void, len: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_FileNode_setValue_int_const_voidX_int(instance: *mut c_void, typ: i32, value: *const c_void, len: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FileNode_real_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FileNode_string_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_mat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_FileNodeIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_FileNodeIterator_const_FileNodeR_bool(node: *const c_void, seek_end: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_FileNodeIterator_const_FileNodeIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_operatorX_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_readRaw_const_StringR_voidX_size_t(instance: *mut c_void, fmt: *const c_char, vec: *mut c_void, len: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_remaining_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_FileNodeIterator_equalTo_const_const_FileNodeIteratorR(instance: *const c_void, it: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileStorage_getPropState_const(instance: *const c_void) -> i32;
		pub fn cv_FileStorage_setPropState_int(instance: *mut c_void, val: i32);
		pub fn cv_FileStorage_getPropElname_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_FileStorage_setPropElname_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_FileStorage_FileStorage(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_FileStorage_const_StringR_int_const_StringR(filename: *const c_char, flags: i32, encoding: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_open_const_StringR_int_const_StringR(instance: *mut c_void, filename: *const c_char, flags: i32, encoding: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileStorage_isOpened_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileStorage_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_releaseAndGetString(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_getFirstTopLevelNode_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_root_const_int(instance: *const c_void, streamidx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_operator___const_const_StringR(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_operator___const_const_charX(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_write_const_StringR_int(instance: *mut c_void, name: *const c_char, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_write_const_StringR_double(instance: *mut c_void, name: *const c_char, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_write_const_StringR_const_StringR(instance: *mut c_void, name: *const c_char, val: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_write_const_StringR_const_MatR(instance: *mut c_void, name: *const c_char, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_write_const_StringR_const_vectorLStringGR(instance: *mut c_void, name: *const c_char, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_writeRaw_const_StringR_const_voidX_size_t(instance: *mut c_void, fmt: *const c_char, vec: *const c_void, len: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_writeComment_const_StringR_bool(instance: *mut c_void, comment: *const c_char, append: bool, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_startWriteStruct_const_StringR_int_const_StringR(instance: *mut c_void, name: *const c_char, flags: i32, type_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_endWriteStruct(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_getDefaultObjectName_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_getFormat_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Formatted_next(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Formatted_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_format_const_const_MatR(instance: *const c_void, mtx: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Formatter_set16fPrecision_int(instance: *mut c_void, p: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_set32fPrecision_int(instance: *mut c_void, p: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_set64fPrecision_int(instance: *mut c_void, p: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_setMultiline_bool(instance: *mut c_void, ml: bool, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_get_FormatType(fmt: core::Formatter_FormatType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Hamming_operator___const_const_unsigned_charX_const_unsigned_charX_int(instance: *const c_void, a: *const u8, b: *const u8, size: i32, ocvrs_return: *mut Result<core::Hamming_result_type>);
		pub fn cv_KeyPoint_getPropPt_const(instance: *const c_void, ocvrs_return: *mut core::Point2f);
		pub fn cv_KeyPoint_setPropPt_Point2f(instance: *mut c_void, val: *const core::Point2f);
		pub fn cv_KeyPoint_getPropSize_const(instance: *const c_void) -> f32;
		pub fn cv_KeyPoint_setPropSize_float(instance: *mut c_void, val: f32);
		pub fn cv_KeyPoint_getPropAngle_const(instance: *const c_void) -> f32;
		pub fn cv_KeyPoint_setPropAngle_float(instance: *mut c_void, val: f32);
		pub fn cv_KeyPoint_getPropResponse_const(instance: *const c_void) -> f32;
		pub fn cv_KeyPoint_setPropResponse_float(instance: *mut c_void, val: f32);
		pub fn cv_KeyPoint_getPropOctave_const(instance: *const c_void) -> i32;
		pub fn cv_KeyPoint_setPropOctave_int(instance: *mut c_void, val: i32);
		pub fn cv_KeyPoint_getPropClass_id_const(instance: *const c_void) -> i32;
		pub fn cv_KeyPoint_setPropClass_id_int(instance: *mut c_void, val: i32);
		pub fn cv_KeyPoint_KeyPoint(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_KeyPoint_Point2f_float_float_float_int_int(pt: *const core::Point2f, size: f32, angle: f32, response: f32, octave: i32, class_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_KeyPoint_float_float_float_float_float_int_int(x: f32, y: f32, size: f32, angle: f32, response: f32, octave: i32, class_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_hash_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_KeyPoint_convert_const_vectorLKeyPointGR_vectorLPoint2fGR_const_vectorLintGR(keypoints: *const c_void, points2f: *mut c_void, keypoint_indexes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPoint_convert_const_vectorLPoint2fGR_vectorLKeyPointGR_float_float_int_int(points2f: *const c_void, keypoints: *mut c_void, size: f32, response: f32, octave: i32, class_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPoint_overlap_const_KeyPointR_const_KeyPointR(kp1: *const c_void, kp2: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_LDA_LDA_int(num_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_LDA_const__InputArrayR_const__InputArrayR_int(src: *const c_void, labels: *const c_void, num_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_save_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_LDA_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_LDA_save_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LDA_load_const_FileStorageR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LDA_compute_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, labels: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LDA_project_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_reconstruct_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_eigenvectors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_eigenvalues_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_subspaceProject_const__InputArrayR_const__InputArrayR_const__InputArrayR(w: *const c_void, mean: *const c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_subspaceReconstruct_const__InputArrayR_const__InputArrayR_const__InputArrayR(w: *const c_void, mean: *const c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_getPropFlags_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_setPropFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_getPropDims_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_setPropDims_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_getPropRows_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_setPropRows_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_getPropCols_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_setPropCols_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_getPropData(instance: *mut c_void) -> *mut u8;
		pub fn cv_Mat_setPropData_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_Mat_getPropDatastart_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_getPropDataend_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_getPropDatalimit_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_getPropU(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Mat_setPropU_UMatDataX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_Mat_getPropSize_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Mat_getPropStep_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Mat_Mat() -> *mut c_void;
		pub fn cv_Mat_Mat_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_int_int_const_ScalarR(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int_const_ScalarR(size: *const core::Size, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int(ndims: i32, sizes: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int(sizes: *const c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int_const_ScalarR(ndims: i32, sizes: *const i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int_const_ScalarR(sizes: *const c_void, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_int_int_voidX_size_t(rows: i32, cols: i32, typ: i32, data: *mut c_void, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int_voidX_size_t(size: *const core::Size, typ: i32, data: *mut c_void, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int_voidX_const_size_tX(ndims: i32, sizes: *const i32, typ: i32, data: *mut c_void, steps: *const size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int_voidX_const_size_tX(sizes: *const c_void, typ: i32, data: *mut c_void, steps: *const size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_RangeR_const_RangeR(m: *const c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_RectR(m: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_vectorLRangeGR(m: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_GpuMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_getUMat_const_AccessFlag_UMatUsageFlags(instance: *const c_void, access_flags: core::AccessFlag, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_rowRange_const_int_int(instance: *const c_void, startrow: i32, endrow: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_rowRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_colRange_const_int_int(instance: *const c_void, startcol: i32, endcol: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_colRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_diag_const_int(instance: *const c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_diag_const_MatR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_copyTo_const_const__OutputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, m: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_convertTo_const_const__OutputArrayR_int_double_double(instance: *const c_void, m: *const c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_assignTo_const_MatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_setTo_const__InputArrayR_const__InputArrayR(instance: *mut c_void, value: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int_int_const_intX(instance: *const c_void, cn: i32, newndims: i32, newsz: *const i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int_const_vectorLintGR(instance: *const c_void, cn: i32, newshape: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_t_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_inv_const_int(instance: *const c_void, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_mul_const_const__InputArrayR_double(instance: *const c_void, m: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_cross_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_dot_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Mat_zeros_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_zeros_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_zeros_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_ones_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_ones_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_ones_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_eye_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_eye_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_create_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_create_int_const_intX_int(instance: *mut c_void, ndims: i32, sizes: *const i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_create_const_vectorLintGR_int(instance: *mut c_void, sizes: *const c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_addref(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_deallocate(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_reserve_size_t(instance: *mut c_void, sz: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_reserveBuffer_size_t(instance: *mut c_void, sz: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_resize_size_t(instance: *mut c_void, sz: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_resize_size_t_const_ScalarR(instance: *mut c_void, sz: size_t, s: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_push_back_const_MatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_pop_back_size_t(instance: *mut c_void, nelems: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_locateROI_const_SizeR_PointR(instance: *const c_void, whole_size: *mut core::Size, ofs: *mut core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_Range_Range(instance: *const c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_const_RectR(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_const_RangeX(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_const_vectorLRangeGR(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_isContinuous_const(instance: *const c_void) -> bool;
		pub fn cv_Mat_isSubmatrix_const(instance: *const c_void) -> bool;
		pub fn cv_Mat_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_elemSize1_const(instance: *const c_void) -> size_t;
		pub fn cv_Mat_type_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_depth_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_channels_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_step1_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_empty_const(instance: *const c_void) -> bool;
		pub fn cv_Mat_total_const(instance: *const c_void) -> size_t;
		pub fn cv_Mat_total_const_int_int(instance: *const c_void, start_dim: i32, end_dim: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_checkVector_const_int_int_bool(instance: *const c_void, elem_channels: i32, depth: i32, require_continuous: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_Mat_ptr_int(instance: *mut c_void, i0: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_int(instance: *const c_void, i0: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_int_int(instance: *mut c_void, row: i32, col: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_int_int(instance: *const c_void, row: i32, col: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_int_int_int(instance: *mut c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_int_int_int(instance: *const c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_const_intX(instance: *mut c_void, idx: *const i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_const_intX(instance: *const c_void, idx: *const i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_Mat_MatRR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_updateContinuityFlag(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatConstIterator_getPropM_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatConstIterator_getPropElemSize_const(instance: *const c_void) -> size_t;
		pub fn cv_MatConstIterator_setPropElemSize_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_MatConstIterator_getPropPtr_const(instance: *const c_void) -> *const u8;
		pub fn cv_MatConstIterator_getPropSliceStart_const(instance: *const c_void) -> *const u8;
		pub fn cv_MatConstIterator_getPropSliceEnd_const(instance: *const c_void) -> *const u8;
		pub fn cv_MatConstIterator_MatConstIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX(_m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_int_int(_m: *const c_void, _row: i32, _col: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_Point(_m: *const c_void, _pt: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatConstIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_operatorX_const(instance: *const c_void, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_MatConstIterator_operator___const_ptrdiff_t(instance: *const c_void, i: ptrdiff_t, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_MatConstIterator_operatorSS(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_pos_const(instance: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_MatConstIterator_pos_const_intX(instance: *const c_void, _idx: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_MatConstIterator_lpos_const(instance: *const c_void, ocvrs_return: *mut Result<ptrdiff_t>);
		pub fn cv_MatConstIterator_seek_ptrdiff_t_bool(instance: *mut c_void, ofs: ptrdiff_t, relative: bool, ocvrs_return: *mut Result_void);
		pub fn cv_MatConstIterator_seek_const_intX_bool(instance: *mut c_void, _idx: *const i32, relative: bool, ocvrs_return: *mut Result_void);
		pub fn cv_MatExpr_getPropFlags_const(instance: *const c_void) -> i32;
		pub fn cv_MatExpr_setPropFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_MatExpr_getPropA_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatExpr_setPropA_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_MatExpr_getPropB_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatExpr_setPropB_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_MatExpr_getPropC_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatExpr_setPropC_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_MatExpr_getPropAlpha_const(instance: *const c_void) -> f64;
		pub fn cv_MatExpr_setPropAlpha_double(instance: *mut c_void, val: f64);
		pub fn cv_MatExpr_getPropBeta_const(instance: *const c_void) -> f64;
		pub fn cv_MatExpr_setPropBeta_double(instance: *mut c_void, val: f64);
		pub fn cv_MatExpr_getPropS_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_MatExpr_setPropS_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_MatExpr_MatExpr(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_MatExpr_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_MatExpr_const_MatOpX_int_const_MatR_const_MatR_const_MatR_double_double_const_ScalarR(_op: *const c_void, _flags: i32, _a: *const c_void, _b: *const c_void, _c: *const c_void, _alpha: f64, _beta: f64, _s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_operator_cv_Mat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_MatExpr_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatExpr_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_diag_const_int(instance: *const c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_operator___const_const_RangeR_const_RangeR(instance: *const c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_operator___const_const_RectR(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_t_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_inv_const_int(instance: *const c_void, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_mul_const_const_MatExprR_double(instance: *const c_void, e: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_mul_const_const_MatR_double(instance: *const c_void, m: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_cross_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_dot_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MatExpr_swap_MatExprR(instance: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_elementWise_const_const_MatExprR(instance: *const c_void, expr: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_MatOp_assign_const_const_MatExprR_MatR_int(instance: *const c_void, expr: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_roi_const_const_MatExprR_const_RangeR_const_RangeR_MatExprR(instance: *const c_void, expr: *const c_void, row_range: *const c_void, col_range: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_diag_const_const_MatExprR_int_MatExprR(instance: *const c_void, expr: *const c_void, d: i32, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignAdd_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignSubtract_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignMultiply_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignDivide_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignAnd_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignOr_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignXor_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_add_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_add_const_const_MatExprR_const_ScalarR_MatExprR(instance: *const c_void, expr1: *const c_void, s: *const core::Scalar, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_subtract_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_subtract_const_const_ScalarR_const_MatExprR_MatExprR(instance: *const c_void, s: *const core::Scalar, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_multiply_const_const_MatExprR_const_MatExprR_MatExprR_double(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_multiply_const_const_MatExprR_double_MatExprR(instance: *const c_void, expr1: *const c_void, s: f64, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_divide_const_const_MatExprR_const_MatExprR_MatExprR_double(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_divide_const_double_const_MatExprR_MatExprR(instance: *const c_void, s: f64, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_abs_const_const_MatExprR_MatExprR(instance: *const c_void, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_transpose_const_const_MatExprR_MatExprR(instance: *const c_void, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_matmul_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_invert_const_const_MatExprR_int_MatExprR(instance: *const c_void, expr: *const c_void, method: i32, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_size_const_const_MatExprR(instance: *const c_void, expr: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_MatOp_type_const_const_MatExprR(instance: *const c_void, expr: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatSize_getPropP(instance: *mut c_void) -> *mut i32;
		pub fn cv_MatSize_setPropP_intX(instance: *mut c_void, val: *mut i32);
		pub fn cv_MatSize_MatSize_intX(_p: *mut i32) -> *mut c_void;
		pub fn cv_MatSize_dims_const(instance: *const c_void) -> i32;
		pub fn cv_MatSize_operator___const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_MatSize_operator___const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatSize_operator___int(instance: *mut c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatSize_operator_const_intX_const(instance: *const c_void) -> *const i32;
		pub fn cv_MatSize_operatorEQ_const_const_MatSizeR(instance: *const c_void, sz: *const c_void) -> bool;
		pub fn cv_MatSize_operatorNE_const_const_MatSizeR(instance: *const c_void, sz: *const c_void) -> bool;
		pub fn cv_MatStep_getPropP(instance: *mut c_void) -> *mut size_t;
		pub fn cv_MatStep_setPropP_size_tX(instance: *mut c_void, val: *mut size_t);
		pub fn cv_MatStep_getPropBuf(instance: *mut c_void) -> *mut [size_t; 2];
		pub fn cv_MatStep_MatStep() -> *mut c_void;
		pub fn cv_MatStep_MatStep_size_t(s: size_t) -> *mut c_void;
		pub fn cv_MatStep_operator___const_int(instance: *const c_void, i: i32) -> size_t;
		pub fn cv_MatStep_operator___int(instance: *mut c_void, i: i32) -> size_t;
		pub fn cv_MatStep_operator_size_t_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Matx_AddOp_Matx_AddOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_AddOp_Matx_AddOp_const_Matx_AddOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_DivOp_Matx_DivOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_DivOp_Matx_DivOp_const_Matx_DivOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MatMulOp_Matx_MatMulOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MatMulOp_Matx_MatMulOp_const_Matx_MatMulOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MulOp_Matx_MulOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MulOp_Matx_MulOp_const_Matx_MulOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_ScaleOp_Matx_ScaleOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_ScaleOp_Matx_ScaleOp_const_Matx_ScaleOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_SubOp_Matx_SubOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_SubOp_Matx_SubOp_const_Matx_SubOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_TOp_Matx_TOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_TOp_Matx_TOp_const_Matx_TOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MinProblemSolver_getFunction_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MinProblemSolver_setFunction_const_PtrLFunctionGR(instance: *mut c_void, f: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MinProblemSolver_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_MinProblemSolver_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_MinProblemSolver_minimize_const__InputOutputArrayR(instance: *mut c_void, x: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MinProblemSolver_Function_getDims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MinProblemSolver_Function_getGradientEps_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MinProblemSolver_Function_calc_const_const_doubleX(instance: *const c_void, x: *const f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_MinProblemSolver_Function_getGradient_const_doubleX_doubleX(instance: *mut c_void, x: *const f64, grad: *mut f64, ocvrs_return: *mut Result_void);
		pub fn cv_Moments_Moments(ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_Moments_Moments_double_double_double_double_double_double_double_double_double_double(m00: f64, m10: f64, m01: f64, m20: f64, m11: f64, m02: f64, m30: f64, m21: f64, m12: f64, m03: f64, ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_PCA_getPropEigenvectors_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PCA_setPropEigenvectors_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_PCA_getPropEigenvalues_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PCA_setPropEigenvalues_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_PCA_getPropMean_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PCA_setPropMean_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_PCA_PCA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_PCA_const__InputArrayR_const__InputArrayR_int_int(data: *const c_void, mean: *const c_void, flags: i32, max_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_PCA_const__InputArrayR_const__InputArrayR_int_double(data: *const c_void, mean: *const c_void, flags: i32, retained_variance: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_operator___const__InputArrayR_const__InputArrayR_int_int(instance: *mut c_void, data: *const c_void, mean: *const c_void, flags: i32, max_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_operator___const__InputArrayR_const__InputArrayR_int_double(instance: *mut c_void, data: *const c_void, mean: *const c_void, flags: i32, retained_variance: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_project_const_const__InputArrayR(instance: *const c_void, vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_project_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, vec: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCA_backProject_const_const__InputArrayR(instance: *const c_void, vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_backProject_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, vec: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCA_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCA_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ParallelLoopBody_operator___const_const_RangeR(instance: *const c_void, range: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_RNG_getPropState_const(instance: *const c_void) -> u64;
		pub fn cv_RNG_setPropState_uint64_t(instance: *mut c_void, val: u64);
		pub fn cv_RNG_RNG(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_RNG_uint64_t(state: u64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_next(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_operator_unsigned_char(instance: *mut c_void, ocvrs_return: *mut Result<u8>);
		pub fn cv_RNG_operator_signed_char(instance: *mut c_void, ocvrs_return: *mut Result<i8>);
		pub fn cv_RNG_operator_unsigned_short(instance: *mut c_void, ocvrs_return: *mut Result<u16>);
		pub fn cv_RNG_operator_short(instance: *mut c_void, ocvrs_return: *mut Result<i16>);
		pub fn cv_RNG_operator_unsigned_int(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_operator_int(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_operator_float(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_operator_double(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_operator__(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_operator___unsigned_int(instance: *mut c_void, n: u32, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_uniform_int_int(instance: *mut c_void, a: i32, b: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_uniform_float_float(instance: *mut c_void, a: f32, b: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_uniform_double_double(instance: *mut c_void, a: f64, b: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_fill_const__InputOutputArrayR_int_const__InputArrayR_const__InputArrayR_bool(instance: *mut c_void, mat: *const c_void, dist_type: i32, a: *const c_void, b: *const c_void, saturate_range: bool, ocvrs_return: *mut Result_void);
		pub fn cv_RNG_gaussian_double(instance: *mut c_void, sigma: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_operatorEQ_const_const_RNGR(instance: *const c_void, other: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_RNG_MT19937_RNG_MT19937(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_MT19937_RNG_MT19937_unsigned_int(s: u32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_MT19937_seed_unsigned_int(instance: *mut c_void, s: u32, ocvrs_return: *mut Result_void);
		pub fn cv_RNG_MT19937_next(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_operator_int(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_MT19937_operator_unsigned_int(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_operator_float(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_MT19937_operator_double(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_MT19937_operator___unsigned_int(instance: *mut c_void, n: u32, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_operator__(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_uniform_int_int(instance: *mut c_void, a: i32, b: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_MT19937_uniform_float_float(instance: *mut c_void, a: f32, b: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_MT19937_uniform_double_double(instance: *mut c_void, a: f64, b: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_Range_getPropStart_const(instance: *const c_void) -> i32;
		pub fn cv_Range_setPropStart_int(instance: *mut c_void, val: i32);
		pub fn cv_Range_getPropEnd_const(instance: *const c_void) -> i32;
		pub fn cv_Range_setPropEnd_int(instance: *mut c_void, val: i32);
		pub fn cv_Range_Range(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Range_Range_int_int(_start: i32, _end: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Range_size_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Range_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Range_all(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RotatedRect_getPropCenter_const(instance: *const c_void, ocvrs_return: *mut core::Point2f);
		pub fn cv_RotatedRect_setPropCenter_Point2f(instance: *mut c_void, val: *const core::Point2f);
		pub fn cv_RotatedRect_getPropSize_const(instance: *const c_void, ocvrs_return: *mut core::Size2f);
		pub fn cv_RotatedRect_setPropSize_Size2f(instance: *mut c_void, val: *const core::Size2f);
		pub fn cv_RotatedRect_getPropAngle_const(instance: *const c_void) -> f32;
		pub fn cv_RotatedRect_setPropAngle_float(instance: *mut c_void, val: f32);
		pub fn cv_RotatedRect_RotatedRect(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RotatedRect_RotatedRect_const_Point2fR_const_Size2fR_float(center: *const core::Point2f, size: *const core::Size2f, angle: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RotatedRect_RotatedRect_const_Point2fR_const_Point2fR_const_Point2fR(point1: *const core::Point2f, point2: *const core::Point2f, point3: *const core::Point2f, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RotatedRect_points_const_Point2fX(instance: *const c_void, pts: *mut core::Point2f, ocvrs_return: *mut Result_void);
		pub fn cv_RotatedRect_boundingRect_const(instance: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_RotatedRect_boundingRect2f_const(instance: *const c_void, ocvrs_return: *mut Result<core::Rect_<f32>>);
		pub fn cv_SVD_getPropU_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SVD_setPropU_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SVD_getPropW_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SVD_setPropW_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SVD_getPropVt_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SVD_setPropVt_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SVD_SVD(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_SVD_const__InputArrayR_int(src: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_operator___const__InputArrayR_int(instance: *mut c_void, src: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_compute_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int(src: *const c_void, w: *const c_void, u: *const c_void, vt: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_compute_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, w: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_backSubst_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(w: *const c_void, u: *const c_void, vt: *const c_void, rhs: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_solveZ_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_backSubst_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, rhs: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_getPropFlags_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_setPropFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_getPropHdr(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SparseMat_setPropHdr_HdrX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SparseMat_SparseMat(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_SparseMat_int_const_intX_int(dims: i32, _sizes: *const i32, _type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_SparseMat_const_SparseMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_SparseMat_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_copyTo_const_SparseMatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_copyTo_const_MatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_convertTo_const_SparseMatR_int_double(instance: *const c_void, m: *mut c_void, rtype: i32, alpha: f64, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_convertTo_const_MatR_int_double_double(instance: *const c_void, m: *mut c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_assignTo_const_SparseMatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_create_int_const_intX_int(instance: *mut c_void, dims: i32, _sizes: *const i32, _type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_addref(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_elemSize_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_elemSize1_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_type_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_depth_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_channels_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_size_const(instance: *const c_void, ocvrs_return: *mut Result<*const i32>);
		pub fn cv_SparseMat_size_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_SparseMat_dims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_SparseMat_nzcount_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_int(instance: *const c_void, i0: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_int_int(instance: *const c_void, i0: i32, i1: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_int_int_int(instance: *const c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_const_intX(instance: *const c_void, idx: *const i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_ptr_int_bool_size_tX(instance: *mut c_void, i0: i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_int_bool_size_tX(instance: *mut c_void, i0: i32, i1: i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_int_int_bool_size_tX(instance: *mut c_void, i0: i32, i1: i32, i2: i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_const_intX_bool_size_tX(instance: *mut c_void, idx: *const i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_erase_int_int_size_tX(instance: *mut c_void, i0: i32, i1: i32, hashval: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_erase_int_int_int_size_tX(instance: *mut c_void, i0: i32, i1: i32, i2: i32, hashval: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_erase_const_intX_size_tX(instance: *mut c_void, idx: *const i32, hashval: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_begin(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_begin_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_end(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_end_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_node_size_t(instance: *mut c_void, nidx: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_node_const_size_t(instance: *const c_void, nidx: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_newNode_const_intX_size_t(instance: *mut c_void, idx: *const i32, hashval: size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_removeNode_size_t_size_t_size_t(instance: *mut c_void, hidx: size_t, nidx: size_t, previdx: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_resizeHashTab_size_t(instance: *mut c_void, newsize: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_Hdr_getPropRefcount_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_Hdr_setPropRefcount_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_Hdr_getPropDims_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_Hdr_setPropDims_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_Hdr_getPropValueOffset_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_Hdr_setPropValueOffset_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_Hdr_getPropNodeSize_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Hdr_setPropNodeSize_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Hdr_getPropNodeCount_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Hdr_setPropNodeCount_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Hdr_getPropFreeList_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Hdr_setPropFreeList_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Hdr_getPropPool_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SparseMat_Hdr_setPropPool_vectorLunsigned_charG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SparseMat_Hdr_getPropHashtab_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SparseMat_Hdr_setPropHashtab_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SparseMat_Hdr_getPropSize(instance: *mut c_void) -> *mut [i32; 32];
		pub fn cv_SparseMat_Hdr_Hdr_int_const_intX_int(_dims: i32, _sizes: *const i32, _type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_Hdr_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_Node_getPropHashval_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Node_setPropHashval_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Node_getPropNext_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Node_setPropNext_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Node_getPropIdx(instance: *mut c_void) -> *mut [i32; 32];
		pub fn cv_SparseMatConstIterator_getPropM_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SparseMatConstIterator_getPropHashidx_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMatConstIterator_setPropHashidx_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMatConstIterator_getPropPtr(instance: *mut c_void) -> *mut u8;
		pub fn cv_SparseMatConstIterator_setPropPtr_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator_const_SparseMatX(_m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator_const_SparseMatConstIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_node_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		#[cfg(not(target_os = "windows"))]
		pub fn cv_SparseMatConstIterator_operatorSS(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_seekEnd(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMatIterator_SparseMatIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_SparseMatIterator_SparseMatX(_m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_SparseMatIterator_const_SparseMatIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_node_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TLSDataContainer_cleanup(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_TermCriteria_TermCriteria(ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_TermCriteria_TermCriteria_int_int_double(typ: i32, max_count: i32, epsilon: f64, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_TermCriteria_isValid_const(instance: *const core::TermCriteria, ocvrs_return: *mut Result<bool>);
		pub fn cv_TickMeter_TickMeter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TickMeter_start(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_TickMeter_stop(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_TickMeter_getTimeTicks_const(instance: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_TickMeter_getTimeMicro_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getTimeMilli_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getTimeSec_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getCounter_const(instance: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_TickMeter_getFPS_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getAvgTimeSec_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getAvgTimeMilli_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_getPropFlags_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_setPropFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_getPropDims_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_setPropDims_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_getPropRows_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_setPropRows_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_getPropCols_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_setPropCols_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_getPropUsageFlags_const(instance: *const c_void, ocvrs_return: *mut core::UMatUsageFlags);
		pub fn cv_UMat_setPropUsageFlags_UMatUsageFlags(instance: *mut c_void, val: core::UMatUsageFlags);
		pub fn cv_UMat_getPropU(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMat_setPropU_UMatDataX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_UMat_getPropOffset_const(instance: *const c_void) -> size_t;
		pub fn cv_UMat_setPropOffset_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_UMat_getPropSize_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_UMat_getPropStep_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_UMat_UMat_UMatUsageFlags(usage_flags: core::UMatUsageFlags) -> *mut c_void;
		pub fn cv_UMat_UMat_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_int_int_const_ScalarR_UMatUsageFlags(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_Size_int_const_ScalarR_UMatUsageFlags(size: *const core::Size, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_const_intX_int_UMatUsageFlags(ndims: i32, sizes: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_const_intX_int_const_ScalarR_UMatUsageFlags(ndims: i32, sizes: *const i32, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_RangeR_const_RangeR(m: *const c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_RectR(m: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_vectorLRangeGR(m: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_getMat_const_AccessFlag(instance: *const c_void, flags: core::AccessFlag, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_rowRange_const_int_int(instance: *const c_void, startrow: i32, endrow: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_rowRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_colRange_const_int_int(instance: *const c_void, startcol: i32, endcol: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_colRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const_int(instance: *const c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const_UMatR_UMatUsageFlags(d: *const c_void, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const_UMatR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_copyTo_const_const__OutputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, m: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_convertTo_const_const__OutputArrayR_int_double_double(instance: *const c_void, m: *const c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_assignTo_const_UMatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_setTo_const__InputArrayR_const__InputArrayR(instance: *mut c_void, value: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_const_int_int_const_intX(instance: *const c_void, cn: i32, newndims: i32, newsz: *const i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_t_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_inv_const_int(instance: *const c_void, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_mul_const_const__InputArrayR_double(instance: *const c_void, m: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_dot_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_UMat_zeros_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_int_const_intX_int_UMatUsageFlags(ndims: i32, sz: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_const_intX_int_UMatUsageFlags(ndims: i32, sz: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_create_int_int_int_UMatUsageFlags(instance: *mut c_void, rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_create_Size_int_UMatUsageFlags(instance: *mut c_void, size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_create_int_const_intX_int_UMatUsageFlags(instance: *mut c_void, ndims: i32, sizes: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_create_const_vectorLintGR_int_UMatUsageFlags(instance: *mut c_void, sizes: *const c_void, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_addref(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_deallocate(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_locateROI_const_SizeR_PointR(instance: *const c_void, whole_size: *mut core::Size, ofs: *mut core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_Range_Range(instance: *const c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_const_RectR(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_const_RangeX(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_const_vectorLRangeGR(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_isContinuous_const(instance: *const c_void) -> bool;
		pub fn cv_UMat_isSubmatrix_const(instance: *const c_void) -> bool;
		pub fn cv_UMat_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_UMat_elemSize1_const(instance: *const c_void) -> size_t;
		pub fn cv_UMat_type_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_depth_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_channels_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_step1_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_UMat_empty_const(instance: *const c_void) -> bool;
		pub fn cv_UMat_total_const(instance: *const c_void) -> size_t;
		pub fn cv_UMat_checkVector_const_int_int_bool(instance: *const c_void, elem_channels: i32, depth: i32, require_continuous: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_UMat_UMat_UMatRR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_handle_const_AccessFlag(instance: *const c_void, access_flags: core::AccessFlag, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ndoffset_const_size_tX(instance: *const c_void, ofs: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_updateContinuityFlag(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMatData_getPropUrefcount_const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_setPropUrefcount_int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_getPropRefcount_const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_setPropRefcount_int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_getPropData(instance: *mut c_void) -> *mut u8;
		pub fn cv_UMatData_setPropData_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_UMatData_getPropOrigdata(instance: *mut c_void) -> *mut u8;
		pub fn cv_UMatData_setPropOrigdata_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_UMatData_getPropSize_const(instance: *const c_void) -> size_t;
		pub fn cv_UMatData_setPropSize_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_UMatData_getPropFlags_const(instance: *const c_void, ocvrs_return: *mut core::UMatData_MemoryFlag);
		pub fn cv_UMatData_setPropFlags_MemoryFlag(instance: *mut c_void, val: core::UMatData_MemoryFlag);
		pub fn cv_UMatData_getPropHandle(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMatData_setPropHandle_voidX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_UMatData_getPropUserdata(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMatData_setPropUserdata_voidX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_UMatData_getPropAllocatorFlags__const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_setPropAllocatorFlags__int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_getPropMapcount_const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_setPropMapcount_int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_getPropOriginalUMatData(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMatData_setPropOriginalUMatData_UMatDataX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_UMatData_lock(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMatData_unlock(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMatData_hostCopyObsolete_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_deviceCopyObsolete_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_deviceMemMapped_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_copyOnMap_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_tempUMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_tempCopiedUMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_markHostCopyObsolete_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_UMatData_markDeviceCopyObsolete_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_UMatData_markDeviceMemMapped_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray__InputArray(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_int_voidX(_flags: i32, _obj: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_MatExprR(expr: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLboolGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_doubleR(val: *const f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_GpuMatR(d_mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLGpuMatGR(d_mat_array: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_BufferR(buf: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_HostMemR(cuda_mem: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_UMatR(um: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLUMatGR(umv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMat_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMat__const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getUMat_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMatVector_const_vectorLMatGR(instance: *const c_void, mv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray_getUMatVector_const_vectorLUMatGR(instance: *const c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray_getGpuMatVector_const_vectorLGpuMatGR(instance: *const c_void, gpumv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray_getGpuMat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getOGlBuffer_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getFlags_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_getObj_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getSz_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv__InputArray_kind_const(instance: *const c_void, ocvrs_return: *mut Result<core::_InputArray_KindFlag>);
		pub fn cv__InputArray_dims_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_cols_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_rows_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_size_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv__InputArray_sizend_const_intX_int(instance: *const c_void, sz: *mut i32, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_sameSize_const_const__InputArrayR(instance: *const c_void, arr: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_total_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_type_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_depth_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_channels_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_isContinuous_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isSubmatrix_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_copyTo_const_const__OutputArrayR(instance: *const c_void, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, arr: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray_offset_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_step_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_isMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isUMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isMatVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isUMatVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isMatx_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isGpuMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isGpuMatVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputOutputArray__InputOutputArray(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_int_voidX(_flags: i32, _obj: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_MatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_vectorLMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_GpuMatR(d_mat: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_BufferR(buf: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_HostMemR(cuda_mem: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_UMatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_vectorLUMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_vectorLMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_GpuMatR(d_mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_vectorLGpuMatGR(d_mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_BufferR(buf: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_HostMemR(cuda_mem: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_vectorLUMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_int_voidX(_flags: i32, _obj: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_MatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_vectorLMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_GpuMatR(d_mat: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_vectorLGpuMatGR(d_mat: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_BufferR(buf: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_HostMemR(cuda_mem: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_UMatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_vectorLUMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_vectorLMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_GpuMatR(d_mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		#[cfg(not(target_os = "windows"))]
		pub fn cv__OutputArray__OutputArray_const_vectorLGpuMatGR(d_mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_BufferR(buf: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_HostMemR(cuda_mem: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_vectorLUMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_fixedSize_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__OutputArray_fixedType_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__OutputArray_needed_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__OutputArray_getMatRef_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getUMatRef_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getGpuMatRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getGpuMatVecRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getOGlBufferRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getHostMemRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_create_const_Size_int_int_bool_DepthMask(instance: *const c_void, sz: *const core::Size, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_create_const_int_int_int_int_bool_DepthMask(instance: *const c_void, rows: i32, cols: i32, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_create_const_int_const_intX_int_int_bool_DepthMask(instance: *const c_void, dims: i32, size: *const i32, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_createSameSize_const_const__InputArrayR_int(instance: *const c_void, arr: *const c_void, mtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_release_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_clear_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_setTo_const_const__InputArrayR_const__InputArrayR(instance: *const c_void, value: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_assign_const_const_UMatR(instance: *const c_void, u: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_assign_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_assign_const_const_vectorLUMatGR(instance: *const c_void, v: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_assign_const_const_vectorLMatGR(instance: *const c_void, v: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_move_const_UMatR(instance: *const c_void, u: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_move_const_MatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BufferPool_BufferPool_StreamR(stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_BufferPool_getBuffer_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_BufferPool_getBuffer_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_BufferPool_getAllocator_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DeviceInfo_DeviceInfo(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DeviceInfo_DeviceInfo_int(device_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DeviceInfo_deviceID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DeviceInfo_totalGlobalMem_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_sharedMemPerBlock_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_regsPerBlock_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_warpSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_memPitch_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_maxThreadsPerBlock_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxThreadsDim_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxGridSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_clockRate_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_totalConstMem_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_majorVersion_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_minorVersion_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_textureAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_texturePitchAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_multiProcessorCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_kernelExecTimeoutEnabled_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_integrated_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_canMapHostMemory_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_computeMode_const(instance: *const c_void, ocvrs_return: *mut Result<core::DeviceInfo_ComputeMode>);
		pub fn cv_cuda_DeviceInfo_maxTexture1D_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxTexture1DMipmap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxTexture1DLinear_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxTexture2D_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxTexture2DMipmap_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxTexture2DLinear_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxTexture2DGather_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxTexture3D_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxTextureCubemap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxTexture1DLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxTexture2DLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxTextureCubemapLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxSurface1D_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxSurface2D_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxSurface3D_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxSurface1DLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxSurface2DLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxSurfaceCubemap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxSurfaceCubemapLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_surfaceAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_concurrentKernels_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_ECCEnabled_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_pciBusID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_pciDeviceID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_pciDomainID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_tccDriver_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_asyncEngineCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_unifiedAddressing_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_memoryClockRate_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_memoryBusWidth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_l2CacheSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxThreadsPerMultiProcessor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_queryMemory_const_size_tR_size_tR(instance: *const c_void, total_memory: *mut size_t, free_memory: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DeviceInfo_freeMemory_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_totalMemory_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_supports_const_FeatureSet(instance: *const c_void, feature_set: core::FeatureSet, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_isCompatible_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_Event_Event_const_CreateFlags(flags: core::Event_CreateFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Event_record_StreamR(instance: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Event_queryIfComplete_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_Event_waitForCompletion(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Event_elapsedTime_const_EventR_const_EventR(start: *const c_void, end: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_cuda_GpuData_getPropData(instance: *mut c_void) -> *mut u8;
		pub fn cv_cuda_GpuData_setPropData_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_cuda_GpuData_getPropSize_const(instance: *const c_void) -> size_t;
		pub fn cv_cuda_GpuData_setPropSize_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_cuda_GpuData_GpuData_size_t(_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_getPropFlags_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_GpuMat_setPropFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_GpuMat_getPropRows_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_GpuMat_setPropRows_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_GpuMat_getPropCols_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_GpuMat_setPropCols_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_GpuMat_getPropStep_const(instance: *const c_void) -> size_t;
		pub fn cv_cuda_GpuMat_setPropStep_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_cuda_GpuMat_getPropData(instance: *mut c_void) -> *mut u8;
		pub fn cv_cuda_GpuMat_setPropData_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_cuda_GpuMat_getPropRefcount(instance: *mut c_void) -> *mut i32;
		pub fn cv_cuda_GpuMat_setPropRefcount_intX(instance: *mut c_void, val: *mut i32);
		pub fn cv_cuda_GpuMat_getPropDatastart(instance: *mut c_void) -> *mut u8;
		pub fn cv_cuda_GpuMat_setPropDatastart_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_cuda_GpuMat_getPropDataend_const(instance: *const c_void) -> *const u8;
		pub fn cv_cuda_GpuMat_getPropAllocator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_GpuMat_setPropAllocator_AllocatorX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_GpuMat_defaultAllocator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_setDefaultAllocator_AllocatorX(allocator: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_GpuMat_AllocatorX(allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_int_int_int_AllocatorX(rows: i32, cols: i32, typ: i32, allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_Size_int_AllocatorX(size: *const core::Size, typ: i32, allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_int_int_int_Scalar_AllocatorX(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_Size_int_Scalar_AllocatorX(size: *const core::Size, typ: i32, s: *const core::Scalar, allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_const_GpuMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_int_int_int_voidX_size_t(rows: i32, cols: i32, typ: i32, data: *mut c_void, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_Size_int_voidX_size_t(size: *const core::Size, typ: i32, data: *mut c_void, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_const_GpuMatR_Range_Range(m: *const c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_const_GpuMatR_Rect(m: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_const__InputArrayR_AllocatorX(arr: *const c_void, allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_create_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_swap_GpuMatR(instance: *mut c_void, mat: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_upload_const__InputArrayR(instance: *mut c_void, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_upload_const__InputArrayR_StreamR(instance: *mut c_void, arr: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_download_const_const__OutputArrayR(instance: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_download_const_const__OutputArrayR_StreamR(instance: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_copyTo_const_const__OutputArrayR(instance: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_copyTo_const_const__OutputArrayR_StreamR(instance: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_copyTo_const_const__OutputArrayR_const__InputArrayR_StreamR(instance: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_setTo_Scalar(instance: *mut c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_setTo_Scalar_StreamR(instance: *mut c_void, s: *const core::Scalar, stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_setTo_Scalar_const__InputArrayR(instance: *mut c_void, s: *const core::Scalar, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_setTo_Scalar_const__InputArrayR_StreamR(instance: *mut c_void, s: *const core::Scalar, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int(instance: *const c_void, dst: *const c_void, rtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int_StreamR(instance: *const c_void, dst: *const c_void, rtype: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int_double_double(instance: *const c_void, dst: *const c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int_double_StreamR(instance: *const c_void, dst: *const c_void, rtype: i32, alpha: f64, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int_double_double_StreamR(instance: *const c_void, dst: *const c_void, rtype: i32, alpha: f64, beta: f64, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_assignTo_const_GpuMatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_ptr_int(instance: *mut c_void, y: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_cuda_GpuMat_ptr_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_cuda_GpuMat_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_rowRange_const_int_int(instance: *const c_void, startrow: i32, endrow: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_rowRange_const_Range(instance: *const c_void, r: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_colRange_const_int_int(instance: *const c_void, startcol: i32, endcol: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_colRange_const_Range(instance: *const c_void, r: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_operator___const_Range_Range(instance: *const c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_operator___const_Rect(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_locateROI_const_SizeR_PointR(instance: *const c_void, whole_size: *mut core::Size, ofs: *mut core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_isContinuous_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMat_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMat_elemSize1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMat_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_GpuMat_depth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_GpuMat_channels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_GpuMat_step1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMat_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_cuda_GpuMat_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMat_cudaPtr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_updateContinuityFlag(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_Allocator_allocate_GpuMatX_int_int_size_t(instance: *mut c_void, mat: *mut c_void, rows: i32, cols: i32, elem_size: size_t, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMat_Allocator_free_GpuMatX(instance: *mut c_void, mat: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_getPropFlags_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_GpuMatND_setPropFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_GpuMatND_getPropDims_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_GpuMatND_setPropDims_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_GpuMatND_getPropSize_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_cuda_GpuMatND_setPropSize_SizeArray(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_GpuMatND_getPropStep_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_cuda_GpuMatND_setPropStep_StepArray(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_GpuMatND_GpuMatND(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_GpuMatND_SizeArray_int(size: *mut c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_GpuMatND_SizeArray_int_voidX_StepArray(size: *mut c_void, typ: i32, data: *mut c_void, step: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_create_SizeArray_int(instance: *mut c_void, size: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_swap_GpuMatNDR(instance: *mut c_void, m: *mut c_void);
		pub fn cv_cuda_GpuMatND_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_clone_const_StreamR(instance: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_operator___const_const_vectorLRangeGR(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_createGpuMatHeader_const_IndexArray_Range_Range(instance: *const c_void, idx: *mut c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_createGpuMatHeader_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_operator___const_IndexArray_Range_Range(instance: *const c_void, idx: *mut c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_operator_cv_cuda_GpuMat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_GpuMatND_const_GpuMatNDR(unnamed: *const c_void) -> *mut c_void;
		pub fn cv_cuda_GpuMatND_GpuMatND_GpuMatNDRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_GpuMatND_upload_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_upload_const__InputArrayR_StreamR(instance: *mut c_void, src: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_download_const_const__OutputArrayR(instance: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_download_const_const__OutputArrayR_StreamR(instance: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_isContinuous_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMatND_isSubmatrix_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMatND_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMatND_elemSize1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMatND_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMatND_external_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMatND_getDevicePtr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_cuda_GpuMatND_total_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMatND_totalMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMatND_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HostMem_getPropFlags_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_HostMem_setPropFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_HostMem_getPropRows_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_HostMem_setPropRows_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_HostMem_getPropCols_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_HostMem_setPropCols_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_HostMem_getPropStep_const(instance: *const c_void) -> size_t;
		pub fn cv_cuda_HostMem_setPropStep_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_cuda_HostMem_getPropData(instance: *mut c_void) -> *mut u8;
		pub fn cv_cuda_HostMem_setPropData_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_cuda_HostMem_getPropRefcount(instance: *mut c_void) -> *mut i32;
		pub fn cv_cuda_HostMem_setPropRefcount_intX(instance: *mut c_void, val: *mut i32);
		pub fn cv_cuda_HostMem_getPropDatastart(instance: *mut c_void) -> *mut u8;
		pub fn cv_cuda_HostMem_setPropDatastart_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_cuda_HostMem_getPropDataend_const(instance: *const c_void) -> *const u8;
		pub fn cv_cuda_HostMem_getPropAlloc_type_const(instance: *const c_void, ocvrs_return: *mut core::HostMem_AllocType);
		pub fn cv_cuda_HostMem_setPropAlloc_type_AllocType(instance: *mut c_void, val: core::HostMem_AllocType);
		pub fn cv_cuda_HostMem_HostMem_AllocType(alloc_type: core::HostMem_AllocType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_const_HostMemR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_int_int_int_AllocType(rows: i32, cols: i32, typ: i32, alloc_type: core::HostMem_AllocType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_Size_int_AllocType(size: *const core::Size, typ: i32, alloc_type: core::HostMem_AllocType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_const__InputArrayR_AllocType(arr: *const c_void, alloc_type: core::HostMem_AllocType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_swap_HostMemR(instance: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HostMem_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HostMem_create_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HostMem_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HostMem_createMatHeader_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_createGpuMatHeader_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_isContinuous_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_HostMem_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_HostMem_elemSize1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_HostMem_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HostMem_depth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HostMem_channels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HostMem_step1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_HostMem_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_cuda_HostMem_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_Stream_Stream(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Stream_Stream_const_PtrLAllocatorGR(allocator: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Stream_Stream_const_size_t(cuda_flags: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Stream_queryIfComplete_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_Stream_waitForCompletion(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Stream_waitEvent_const_EventR(instance: *mut c_void, event: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Stream_enqueueHostCallback_StreamCallback_voidX(instance: *mut c_void, callback: Option<unsafe extern "C" fn(i32, *mut c_void) -> ()>, user_data: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Stream_Null(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Stream_cudaPtr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_TargetArchs_builtWith_FeatureSet(feature_set: core::FeatureSet, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_has_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasPtx_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasBin_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasEqualOrLessPtx_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasEqualOrGreater_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasEqualOrGreaterPtx_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasEqualOrGreaterBin_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_CheckContext_getPropFunc_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_getPropFile_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_getPropLine_const(instance: *const c_void) -> i32;
		pub fn cv_detail_CheckContext_setPropLine_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_CheckContext_getPropTestOp_const(instance: *const c_void, ocvrs_return: *mut core::Detail_TestOp);
		pub fn cv_detail_CheckContext_setPropTestOp_TestOp(instance: *mut c_void, val: core::Detail_TestOp);
		pub fn cv_detail_CheckContext_getPropMessage_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_getPropP1_str_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_getPropP2_str_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_instr_NodeData_getPropM_funName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_instr_NodeData_setPropM_funName_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_instr_NodeData_getPropM_instrType_const(instance: *const c_void, ocvrs_return: *mut core::TYPE);
		pub fn cv_instr_NodeData_setPropM_instrType_TYPE(instance: *mut c_void, val: core::TYPE);
		pub fn cv_instr_NodeData_getPropM_implType_const(instance: *const c_void, ocvrs_return: *mut core::IMPL);
		pub fn cv_instr_NodeData_setPropM_implType_IMPL(instance: *mut c_void, val: core::IMPL);
		pub fn cv_instr_NodeData_getPropM_fileName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_instr_NodeData_getPropM_lineNum_const(instance: *const c_void) -> i32;
		pub fn cv_instr_NodeData_setPropM_lineNum_int(instance: *mut c_void, val: i32);
		pub fn cv_instr_NodeData_getPropM_retAddress(instance: *mut c_void) -> *mut c_void;
		pub fn cv_instr_NodeData_setPropM_retAddress_voidX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_instr_NodeData_getPropM_alwaysExpand_const(instance: *const c_void) -> bool;
		pub fn cv_instr_NodeData_setPropM_alwaysExpand_bool(instance: *mut c_void, val: bool);
		pub fn cv_instr_NodeData_getPropM_funError_const(instance: *const c_void) -> bool;
		pub fn cv_instr_NodeData_setPropM_funError_bool(instance: *mut c_void, val: bool);
		pub fn cv_instr_NodeData_getPropM_counter_const(instance: *const c_void) -> i32;
		pub fn cv_instr_NodeData_setPropM_counter_int(instance: *mut c_void, val: i32);
		pub fn cv_instr_NodeData_getPropM_ticksTotal_const(instance: *const c_void) -> u64;
		pub fn cv_instr_NodeData_setPropM_ticksTotal_uint64_t(instance: *mut c_void, val: u64);
		pub fn cv_instr_NodeData_getPropM_threads_const(instance: *const c_void) -> i32;
		pub fn cv_instr_NodeData_setPropM_threads_int(instance: *mut c_void, val: i32);
		pub fn cv_instr_NodeData_NodeData_const_charX_const_charX_int_voidX_bool_TYPE_IMPL(fun_name: *const c_char, file_name: *const c_char, line_num: i32, ret_address: *mut c_void, always_expand: bool, instr_type: core::TYPE, impl_type: core::IMPL, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_instr_NodeData_NodeData_NodeDataR(ref_: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_instr_NodeData_getTotalMs_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_instr_NodeData_getMeanMs_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_internal_WriteStructContext_WriteStructContext_FileStorageR_const_StringR_int_const_StringR(_fs: *mut c_void, name: *const c_char, flags: i32, type_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_Context() -> *mut c_void;
		pub fn cv_ocl_Context_Context_int(dtype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_Context_const_ContextR(c: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_Context_ContextRR(c: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Context_create(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_create_int(instance: *mut c_void, dtype: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_ndevices_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Context_device_const_size_t(instance: *const c_void, idx: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_getProg_const_ProgramSourceR_const_StringR_StringR(instance: *mut c_void, prog: *const c_void, buildopt: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_unloadProg_ProgramR(instance: *mut c_void, prog: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Context_getDefault_bool(initialize: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_getOpenCLContextProperty_const_int(instance: *const c_void, property_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_useSVM_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_setUseSVM_bool(instance: *mut c_void, enabled: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Context_fromHandle_voidX(context: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_fromDevice_const_DeviceR(device: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_create_const_stringR(configuration: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Context_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_Device() -> *mut c_void;
		pub fn cv_ocl_Device_Device_voidX(d: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_Device_const_DeviceR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_Device_DeviceRR(d: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Device_set_voidX(instance: *mut c_void, d: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Device_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_extensions_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_isExtensionSupported_const_const_StringR(instance: *const c_void, extension_name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_version_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_vendorName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_OpenCL_C_Version_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_OpenCLVersion_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_deviceVersionMajor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_deviceVersionMinor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_driverVersion_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_addressBits_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_available_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_compilerAvailable_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_linkerAvailable_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_doubleFPConfig_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_singleFPConfig_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_halfFPConfig_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_endianLittle_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_errorCorrectionSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_executionCapabilities_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_globalMemCacheSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_globalMemCacheType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_globalMemCacheLineSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_globalMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_localMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_localMemType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_hostUnifiedMemory_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_imageSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_imageFromBufferSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_imagePitchAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_ocl_Device_imageBaseAddressAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_ocl_Device_intelSubgroupsSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_image2DMaxWidth_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image2DMaxHeight_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image3DMaxWidth_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image3DMaxHeight_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image3DMaxDepth_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_imageMaxBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_imageMaxArraySize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_vendorID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_isAMD_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_isIntel_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_isNVidia_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_maxClockFrequency_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxComputeUnits_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxConstantArgs_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxConstantBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxMemAllocSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxParameterSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxReadImageArgs_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxWriteImageArgs_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxSamplers_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxWorkGroupSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxWorkItemDims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxWorkItemSizes_const_size_tX(instance: *const c_void, unnamed: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Device_memBaseAddrAlign_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthChar_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthShort_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthInt_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthLong_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthFloat_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthDouble_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthHalf_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthChar_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthShort_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthInt_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthLong_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthFloat_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthDouble_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthHalf_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_printfBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_profilingTimerResolution_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_fromHandle_voidX(d: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Image2D_Image2D() -> *mut c_void;
		pub fn cv_ocl_Image2D_Image2D_const_UMatR_bool_bool(src: *const c_void, norm: bool, alias: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Image2D_Image2D_const_Image2DR(i: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Image2D_Image2D_Image2DRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Image2D_canCreateAlias_const_UMatR(u: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Image2D_isFormatSupported_int_int_bool(depth: i32, cn: i32, norm: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Image2D_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_Kernel() -> *mut c_void;
		pub fn cv_ocl_Kernel_Kernel_const_charX_const_ProgramR(kname: *const c_char, prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_Kernel_const_charX_const_ProgramSourceR_const_StringR_StringX(kname: *const c_char, prog: *const c_void, buildopts: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_Kernel_const_KernelR(k: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_Kernel_KernelRR(k: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Kernel_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_create_const_charX_const_ProgramR(instance: *mut c_void, kname: *const c_char, prog: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_create_const_charX_const_ProgramSourceR_const_StringR_StringX(instance: *mut c_void, kname: *const c_char, prog: *const c_void, buildopts: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_set_int_const_voidX_size_t(instance: *mut c_void, i: i32, value: *const c_void, sz: size_t, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_set_int_const_Image2DR(instance: *mut c_void, i: i32, image_2d: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_set_int_const_UMatR(instance: *mut c_void, i: i32, m: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_set_int_const_KernelArgR(instance: *mut c_void, i: i32, arg: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_run_int_size_tX_size_tX_bool_const_QueueR(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, q: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_run__int_size_tX_size_tX_bool_const_QueueR(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, q: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_runTask_bool_const_QueueR(instance: *mut c_void, sync: bool, q: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_runProfiling_int_size_tX_size_tX_const_QueueR(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, q: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_ocl_Kernel_workGroupSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Kernel_preferedWorkGroupSizeMultiple_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Kernel_compileWorkGroupSize_const_size_tX(instance: *const c_void, wsz: *mut size_t, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_localMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Kernel_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_getPropFlags_const(instance: *const c_void) -> i32;
		pub fn cv_ocl_KernelArg_setPropFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_ocl_KernelArg_getPropM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_KernelArg_setPropM_UMatX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_ocl_KernelArg_getPropObj_const(instance: *const c_void) -> *const c_void;
		pub fn cv_ocl_KernelArg_getPropSz_const(instance: *const c_void) -> size_t;
		pub fn cv_ocl_KernelArg_setPropSz_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_ocl_KernelArg_getPropWscale_const(instance: *const c_void) -> i32;
		pub fn cv_ocl_KernelArg_setPropWscale_int(instance: *mut c_void, val: i32);
		pub fn cv_ocl_KernelArg_getPropIwscale_const(instance: *const c_void) -> i32;
		pub fn cv_ocl_KernelArg_setPropIwscale_int(instance: *mut c_void, val: i32);
		pub fn cv_ocl_KernelArg_KernelArg_int_UMatX_int_int_const_voidX_size_t(_flags: i32, _m: *mut c_void, wscale: i32, iwscale: i32, _obj: *const c_void, _sz: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_KernelArg() -> *mut c_void;
		pub fn cv_ocl_KernelArg_Local_size_t(local_mem_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_PtrWriteOnly_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_PtrReadOnly_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_PtrReadWrite_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadWrite_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadWriteNoSize_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadOnly_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_WriteOnly_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadOnlyNoSize_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_WriteOnlyNoSize_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_Constant_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_OpenCLExecutionContext() -> *mut c_void;
		pub fn cv_ocl_OpenCLExecutionContext_OpenCLExecutionContext_const_OpenCLExecutionContextR(unnamed: *const c_void) -> *mut c_void;
		pub fn cv_ocl_OpenCLExecutionContext_OpenCLExecutionContext_OpenCLExecutionContextRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_OpenCLExecutionContext_getContext_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_getDevice_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_getQueue_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_useOpenCL_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_OpenCLExecutionContext_setUseOpenCL_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_OpenCLExecutionContext_getCurrent(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_getCurrentRef(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_bind_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_OpenCLExecutionContext_cloneWithNewQueue_const_const_QueueR(instance: *const c_void, q: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_cloneWithNewQueue_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_create_const_stringR_voidX_voidX_voidX(platform_name: *const c_char, platform_id: *mut c_void, context: *mut c_void, device_id: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_create_const_ContextR_const_DeviceR_const_QueueR(context: *const c_void, device: *const c_void, queue: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_create_const_ContextR_const_DeviceR(context: *const c_void, device: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_OpenCLExecutionContext_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Platform_Platform() -> *mut c_void;
		pub fn cv_ocl_Platform_Platform_const_PlatformR(p: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Platform_Platform_PlatformRR(p: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Platform_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Platform_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Platform_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_PlatformInfo_PlatformInfo() -> *mut c_void;
		pub fn cv_ocl_PlatformInfo_PlatformInfo_voidX(id: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_PlatformInfo_const_PlatformInfoR(i: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_PlatformInfo_PlatformInfoRR(i: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_PlatformInfo_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_vendor_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_version_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_versionMajor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_PlatformInfo_versionMinor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_PlatformInfo_deviceNumber_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_PlatformInfo_getDevice_const_DeviceR_int(instance: *const c_void, device: *mut c_void, d: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_PlatformInfo_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_Program() -> *mut c_void;
		pub fn cv_ocl_Program_Program_const_ProgramSourceR_const_StringR_StringR(src: *const c_void, buildflags: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_Program_const_ProgramR(prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_Program_ProgramRR(prog: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Program_create_const_ProgramSourceR_const_StringR_StringR(instance: *mut c_void, src: *const c_void, buildflags: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_getBinary_const_vectorLcharGR(instance: *const c_void, binary: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Program_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_read_const_StringR_const_StringR(instance: *mut c_void, buf: *const c_char, buildflags: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_write_const_StringR(instance: *const c_void, buf: *mut *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_source_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_getPrefix_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_getPrefix_const_StringR(buildflags: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_ProgramSource() -> *mut c_void;
		pub fn cv_ocl_ProgramSource_ProgramSource_const_StringR_const_StringR_const_StringR_const_StringR(module: *const c_char, name: *const c_char, code_str: *const c_char, code_hash: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_ProgramSource_const_StringR(prog: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_ProgramSource_const_ProgramSourceR(prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_ProgramSource_ProgramSourceRR(prog: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_ProgramSource_source_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_hash_const(instance: *const c_void, ocvrs_return: *mut Result<core::ProgramSource_hash_t>);
		pub fn cv_ocl_ProgramSource_fromBinary_const_StringR_const_StringR_const_unsigned_charX_const_size_t_const_StringR(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, build_options: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_fromSPIR_const_StringR_const_StringR_const_unsigned_charX_const_size_t_const_StringR(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, build_options: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Queue_Queue() -> *mut c_void;
		pub fn cv_ocl_Queue_Queue_const_ContextR_const_DeviceR(c: *const c_void, d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_Queue_const_QueueR(q: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_Queue_QueueRR(q: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Queue_create_const_ContextR_const_DeviceR(instance: *mut c_void, c: *const c_void, d: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Queue_finish(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Queue_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_getProfilingQueue_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Timer_Timer_const_QueueR(q: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Timer_start(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Timer_stop(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Timer_durationNS_const(instance: *const c_void, ocvrs_return: *mut Result<u64>);
		pub fn cv_ogl_Arrays_Arrays(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Arrays_setVertexArray_const__InputArrayR(instance: *mut c_void, vertex: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_resetVertexArray(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_setColorArray_const__InputArrayR(instance: *mut c_void, color: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_resetColorArray(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_setNormalArray_const__InputArrayR(instance: *mut c_void, normal: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_resetNormalArray(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_setTexCoordArray_const__InputArrayR(instance: *mut c_void, tex_coord: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_resetTexCoordArray(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_setAutoRelease_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_bind_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_size_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Arrays_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ogl_Buffer_Buffer(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_int_int_int_unsigned_int_bool(arows: i32, acols: i32, atype: i32, abuf_id: u32, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_Size_int_unsigned_int_bool(asize: *const core::Size, atype: i32, abuf_id: u32, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_int_int_int_Target_bool(arows: i32, acols: i32, atype: i32, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_Size_int_Target_bool(asize: *const core::Size, atype: i32, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_const__InputArrayR_Target_bool(arr: *const c_void, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_create_int_int_int_Target_bool(instance: *mut c_void, arows: i32, acols: i32, atype: i32, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_create_Size_int_Target_bool(instance: *mut c_void, asize: *const core::Size, atype: i32, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_setAutoRelease_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_copyFrom_const__InputArrayR_Target_bool(instance: *mut c_void, arr: *const c_void, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_copyFrom_const__InputArrayR_StreamR_Target_bool(instance: *mut c_void, arr: *const c_void, stream: *mut c_void, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_copyTo_const_const__OutputArrayR(instance: *const c_void, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_copyTo_const_const__OutputArrayR_StreamR(instance: *const c_void, arr: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_clone_const_Target_bool(instance: *const c_void, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_bind_const_Target(instance: *const c_void, target: core::Buffer_Target, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_unbind_Target(target: core::Buffer_Target, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_mapHost_Access(instance: *mut c_void, access: core::Buffer_Access, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_unmapHost(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_mapDevice(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_unmapDevice(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_mapDevice_StreamR(instance: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_unmapDevice_StreamR(instance: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_rows_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_cols_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_ogl_Buffer_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ogl_Buffer_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_depth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_channels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_elemSize1_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_bufId_const(instance: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_ogl_Texture2D_Texture2D(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_int_int_Format_unsigned_int_bool(arows: i32, acols: i32, aformat: core::Texture2D_Format, atex_id: u32, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_Size_Format_unsigned_int_bool(asize: *const core::Size, aformat: core::Texture2D_Format, atex_id: u32, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_int_int_Format_bool(arows: i32, acols: i32, aformat: core::Texture2D_Format, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_Size_Format_bool(asize: *const core::Size, aformat: core::Texture2D_Format, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_const__InputArrayR_bool(arr: *const c_void, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_create_int_int_Format_bool(instance: *mut c_void, arows: i32, acols: i32, aformat: core::Texture2D_Format, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_create_Size_Format_bool(instance: *mut c_void, asize: *const core::Size, aformat: core::Texture2D_Format, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_setAutoRelease_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_copyFrom_const__InputArrayR_bool(instance: *mut c_void, arr: *const c_void, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_copyTo_const_const__OutputArrayR_int_bool(instance: *const c_void, arr: *const c_void, ddepth: i32, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_bind_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_rows_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Texture2D_cols_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Texture2D_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_ogl_Texture2D_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ogl_Texture2D_format_const(instance: *const c_void, ocvrs_return: *mut Result<core::Texture2D_Format>);
		pub fn cv_ogl_Texture2D_texId_const(instance: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_utils_logging_LogTag_getPropName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_utils_logging_LogTag_getPropLevel_const(instance: *const c_void, ocvrs_return: *mut core::LogLevel);
		pub fn cv_utils_logging_LogTag_setPropLevel_LogLevel(instance: *mut c_void, val: core::LogLevel);
		pub fn cv_utils_logging_LogTag_LogTag_const_charX_LogLevel(_name: *const c_char, _level: core::LogLevel, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_OriginalClassName_const_ParamsR(params: *const core::OriginalClassName_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_getIntParam_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_utils_nested_OriginalClassName_getFloatParam_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_utils_nested_OriginalClassName_originalName(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_create_const_ParamsR(params: *const core::OriginalClassName_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_Params_Params_int_float(int_param: i32, float_param: f32, ocvrs_return: *mut Result<core::OriginalClassName_Params>);
	}
}
#[cfg(ocvrs_has_module_core)]
pub use core_sys::*;

#[cfg(ocvrs_has_module_dnn)]
mod dnn_sys {
	use super::*;

	extern "C" {
		pub fn cv_dnn_NMSBoxes_const_vectorLRect2dGR_const_vectorLfloatGR_const_float_const_float_vectorLintGR_const_float_const_int(bboxes: *const c_void, scores: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxes_const_vectorLRectGR_const_vectorLfloatGR_const_float_const_float_vectorLintGR_const_float_const_int(bboxes: *const c_void, scores: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxes_const_vectorLRotatedRectGR_const_vectorLfloatGR_const_float_const_float_vectorLintGR_const_float_const_int(bboxes: *const c_void, scores: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImage_const__InputArrayR_const__OutputArrayR_double_const_SizeR_const_ScalarR_bool_bool_int(image: *const c_void, blob: *const c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImage_const__InputArrayR_double_const_SizeR_const_ScalarR_bool_bool_int(image: *const c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_blobFromImages_const__InputArrayR_const__OutputArrayR_double_Size_const_ScalarR_bool_bool_int(images: *const c_void, blob: *const c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImages_const__InputArrayR_double_Size_const_ScalarR_bool_bool_int(images: *const c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_concat_const_MatShapeR_const_MatShapeR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_enableModelDiagnostics_bool(is_diagnostics_mode: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_getAvailableBackends(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_getAvailableTargets_Backend(be: crate::dnn::Backend, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_getInferenceEngineBackendType(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_getInferenceEngineCPUType(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_getInferenceEngineVPUType(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_getPlane_const_MatR_int_int(m: *const c_void, n: i32, cn: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_imagesFromBlob_const_MatR_const__OutputArrayR(blob_: *const c_void, images_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_readNetFromCaffe_const_StringR_const_StringR(prototxt: *const c_char, caffe_model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromCaffe_const_charX_size_t_const_charX_size_t(buffer_proto: *const c_char, len_proto: size_t, buffer_model: *const c_char, len_model: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromCaffe_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(buffer_proto: *const c_void, buffer_model: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromDarknet_const_StringR_const_StringR(cfg_file: *const c_char, darknet_model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromDarknet_const_charX_size_t_const_charX_size_t(buffer_cfg: *const c_char, len_cfg: size_t, buffer_model: *const c_char, len_model: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromDarknet_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(buffer_cfg: *const c_void, buffer_model: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromModelOptimizer_const_StringR_const_StringR(xml: *const c_char, bin: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromModelOptimizer_const_unsigned_charX_size_t_const_unsigned_charX_size_t(buffer_model_config_ptr: *const u8, buffer_model_config_size: size_t, buffer_weights_ptr: *const u8, buffer_weights_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromModelOptimizer_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(buffer_model_config: *const c_void, buffer_weights: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromONNX_const_StringR(onnx_file: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromONNX_const_charX_size_t(buffer: *const c_char, size_buffer: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromONNX_const_vectorLunsigned_charGR(buffer: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTensorflow_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTensorflow_const_charX_size_t_const_charX_size_t(buffer_model: *const c_char, len_model: size_t, buffer_config: *const c_char, len_config: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTensorflow_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(buffer_model: *const c_void, buffer_config: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTorch_const_StringR_bool_bool(model: *const c_char, is_binary: bool, evaluate: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNet_const_StringR_const_StringR_const_StringR(model: *const c_char, config: *const c_char, framework: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNet_const_StringR_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(framework: *const c_char, buffer_model: *const c_void, buffer_config: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readTensorFromONNX_const_StringR(path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readTorchBlob_const_StringR_bool(filename: *const c_char, is_binary: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_releaseHDDLPlugin(ocvrs_return: *mut Result_void);
		pub fn cv_dnn_resetMyriadDevice(ocvrs_return: *mut Result_void);
		pub fn cv_dnn_setInferenceEngineBackendType_const_StringR(new_backend_type: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_const_MatR(mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_const_MatSizeR(sz: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_const_UMatR(mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_const_intX_const_int(dims: *const i32, n: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_int_int_int_int(a0: i32, a1: i32, a2: i32, a3: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shrinkCaffeModel_const_StringR_const_StringR_const_vectorLStringGR(src: *const c_char, dst: *const c_char, layers_types: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_slice_const_MatR_const__RangeR(m: *const c_void, r0: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_slice_const_MatR_const__RangeR_const__RangeR(m: *const c_void, r0: *const c_void, r1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_slice_const_MatR_const__RangeR_const__RangeR_const__RangeR(m: *const c_void, r0: *const c_void, r1: *const c_void, r2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_slice_const_MatR_const__RangeR_const__RangeR_const__RangeR_const__RangeR(m: *const c_void, r0: *const c_void, r1: *const c_void, r2: *const c_void, r3: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_softNMSBoxes_const_vectorLRectGR_const_vectorLfloatGR_vectorLfloatGR_const_float_const_float_vectorLintGR_size_t_const_float_SoftNMSMethod(bboxes: *const c_void, scores: *const c_void, updated_scores: *mut c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, top_k: size_t, sigma: f32, method: crate::dnn::SoftNMSMethod, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_total_const_MatShapeR_int_int(shape: *const c_void, start: i32, end: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_writeTextGraph_const_StringR_const_StringR(model: *const c_char, output: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_AbsLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AccumLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AcosLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AcoshLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ActivationLayer_forwardSlice_const_const_floatX_floatX_int_size_t_int_int(instance: *const c_void, src: *const f32, dst: *mut f32, len: i32, out_plane_size: size_t, cn0: i32, cn1: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_ActivationLayer_forwardSlice_const_const_intX_const_intX_intX_int_size_t_int_int(instance: *const c_void, src: *const i32, lut: *const i32, dst: *mut i32, len: i32, out_plane_size: size_t, cn0: i32, cn1: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_ActivationLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ArgLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AsinLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AsinhLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AtanLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AtanhLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_BNLLLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_BackendNode_getPropBackendId_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BackendNode_setPropBackendId_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BackendWrapper_getPropBackendId_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BackendWrapper_setPropBackendId_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BackendWrapper_getPropTargetId_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BackendWrapper_setPropTargetId_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BackendWrapper_copyToHost(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_BackendWrapper_setHostDirty(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_BaseConvolutionLayer_getPropKernel_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_setPropKernel_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_getPropStride_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_setPropStride_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_getPropPad_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_setPropPad_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_getPropDilation_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_setPropDilation_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_getPropAdjustPad_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_setPropAdjustPad_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_getPropAdjust_pads_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_setPropAdjust_pads_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_getPropKernel_size_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_setPropKernel_size_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_getPropStrides_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_setPropStrides_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_getPropDilations_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_setPropDilations_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_getPropPads_begin_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_setPropPads_begin_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_getPropPads_end_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_setPropPads_end_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_getPropPadMode_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_setPropPadMode_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_BaseConvolutionLayer_getPropNumOutput_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BaseConvolutionLayer_setPropNumOutput_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BatchNormLayer_getPropHasWeights_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_BatchNormLayer_setPropHasWeights_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_BatchNormLayer_getPropHasBias_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_BatchNormLayer_setPropHasBias_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_BatchNormLayer_getPropEpsilon_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_BatchNormLayer_setPropEpsilon_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_BatchNormLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_BatchNormLayerInt8_getPropInput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_BatchNormLayerInt8_setPropInput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_BatchNormLayerInt8_getPropOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_BatchNormLayerInt8_setPropOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_BatchNormLayerInt8_getPropInput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BatchNormLayerInt8_setPropInput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BatchNormLayerInt8_getPropOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BatchNormLayerInt8_setPropOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BatchNormLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_BlankLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CeilLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CeluLayer_getPropAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_CeluLayer_setPropAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_CeluLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ChannelsPReLULayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_ClassificationModel(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_ClassificationModel_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_ClassificationModel_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_setEnableSoftmaxPostProcessing_bool(instance: *mut c_void, enable: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_getEnableSoftmaxPostProcessing_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_ClassificationModel_classify_const__InputArrayR(instance: *mut c_void, frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_classify_const__InputArrayR_intR_floatR(instance: *mut c_void, frame: *const c_void, class_id: *mut i32, conf: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_CompareLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ConcatLayer_getPropAxis_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ConcatLayer_setPropAxis_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ConcatLayer_getPropPadding_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_ConcatLayer_setPropPadding_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_ConcatLayer_getPropPaddingValue_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ConcatLayer_setPropPaddingValue_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ConcatLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ConstLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ConvolutionLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ConvolutionLayerInt8_getPropInput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ConvolutionLayerInt8_setPropInput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ConvolutionLayerInt8_getPropOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ConvolutionLayerInt8_setPropOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ConvolutionLayerInt8_getPropInput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ConvolutionLayerInt8_setPropInput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ConvolutionLayerInt8_getPropOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ConvolutionLayerInt8_setPropOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ConvolutionLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CorrelationLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CosLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CoshLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CropAndResizeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CropLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CumSumLayer_getPropExclusive_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_CumSumLayer_setPropExclusive_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_CumSumLayer_getPropReverse_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_CumSumLayer_setPropReverse_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_CumSumLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DataAugmentationLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DeconvolutionLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DequantizeLayer_getPropScale_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_DequantizeLayer_setPropScale_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_DequantizeLayer_getPropZeropoint_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_DequantizeLayer_setPropZeropoint_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_DequantizeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionModel_DetectionModel_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionModel_DetectionModel_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionModel_DetectionModel(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionModel_setNmsAcrossClasses_bool(instance: *mut c_void, value: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionModel_getNmsAcrossClasses(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_DetectionModel_detect_const__InputArrayR_vectorLintGR_vectorLfloatGR_vectorLRectGR_float_float(instance: *mut c_void, frame: *const c_void, class_ids: *mut c_void, confidences: *mut c_void, boxes: *mut c_void, conf_threshold: f32, nms_threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_DetectionOutputLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_has_const_const_StringR(instance: *const c_void, key: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Dict_ptr_const_StringR(instance: *mut c_void, key: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_ptr_const_const_StringR(instance: *const c_void, key: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_get_const_const_StringR(instance: *const c_void, key: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_set_cv_String_const_StringR_const_StringR(instance: *mut c_void, key: *const c_char, value: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_set_cv_dnn_DictValue_const_StringR_const_DictValueR(instance: *mut c_void, key: *const c_char, value: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_set_double_const_StringR_const_doubleR(instance: *mut c_void, key: *const c_char, value: *const f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_dnn_Dict_set_int64_t_const_StringR_const_int64_tR(instance: *mut c_void, key: *const c_char, value: *const i64, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Dict_erase_const_StringR(instance: *mut c_void, key: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_DictValue_DictValue_const_DictValueR(r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_bool(i: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_int64_t(i: i64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_int(i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_unsigned_int(p: u32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_double(p: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_const_charX(s: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_get_cv_String_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_get_double_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_dnn_DictValue_get_int_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_DictValue_get_int64_t_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_DictValue_size_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_DictValue_isInt_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_DictValue_isString_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_DictValue_isReal_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_DictValue_getIntValue_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_DictValue_getRealValue_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_dnn_DictValue_getStringValue_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ELULayer_getPropAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ELULayer_setPropAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ELULayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_EltwiseLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_EltwiseLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ErfLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ExpLayer_getPropBase_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ExpLayer_setPropBase_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ExpLayer_getPropScale_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ExpLayer_setPropScale_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ExpLayer_getPropShift_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ExpLayer_setPropShift_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ExpLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_FlattenLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_FloorLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_FlowWarpLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_GRULayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_HardSigmoidLayer_getPropAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_HardSigmoidLayer_setPropAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_HardSigmoidLayer_getPropBeta_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_HardSigmoidLayer_setPropBeta_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_HardSigmoidLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_HardSwishLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_InnerProductLayer_getPropAxis_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_InnerProductLayer_setPropAxis_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_InnerProductLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_InnerProductLayerInt8_getPropInput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_InnerProductLayerInt8_setPropInput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_InnerProductLayerInt8_getPropOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_InnerProductLayerInt8_setPropOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_InnerProductLayerInt8_getPropInput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_InnerProductLayerInt8_setPropInput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_InnerProductLayerInt8_getPropOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_InnerProductLayerInt8_setPropOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_InnerProductLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_InterpLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_KeypointsModel_KeypointsModel_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_KeypointsModel_KeypointsModel_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_KeypointsModel_estimate_const__InputArrayR_float(instance: *mut c_void, frame: *const c_void, thresh: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_LRNLayer_getPropType_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_LRNLayer_setPropType_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_LRNLayer_getPropSize_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_LRNLayer_setPropSize_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_LRNLayer_getPropAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_LRNLayer_setPropAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_LRNLayer_getPropBeta_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_LRNLayer_setPropBeta_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_LRNLayer_getPropBias_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_LRNLayer_setPropBias_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_LRNLayer_getPropNormBySize_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_LRNLayer_setPropNormBySize_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_LRNLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_LSTMLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_LSTMLayer_setWeights_const_MatR_const_MatR_const_MatR(instance: *mut c_void, wh: *const c_void, wx: *const c_void, b: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_setOutShape_const_MatShapeR(instance: *mut c_void, out_tail_shape: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_setUseTimstampsDim_bool(instance: *mut c_void, use_: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_setProduceCellOutput_bool(instance: *mut c_void, produce: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_inputNameToIndex_String(instance: *mut c_void, input_name: *mut c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_LSTMLayer_outputNameToIndex_const_StringR(instance: *mut c_void, output_name: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Layer_getPropBlobs_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_setPropBlobs_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_Layer_getPropName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_setPropName_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_Layer_getPropType_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_setPropType_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_Layer_getPropPreferableTarget_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_Layer_setPropPreferableTarget_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_Layer_finalize_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, inputs: *const c_void, outputs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_forward_vectorLMatXGR_vectorLMatGR_vectorLMatGR(instance: *mut c_void, input: *mut c_void, output: *mut c_void, internals: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_forward_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, inputs: *const c_void, outputs: *const c_void, internals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_tryQuantize_const_vectorLvectorLfloatGGR_const_vectorLvectorLintGGR_LayerParamsR(instance: *mut c_void, scales: *const c_void, zeropoints: *const c_void, params: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_forward_fallback_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, inputs: *const c_void, outputs: *const c_void, internals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_finalize_const_vectorLMatGR_vectorLMatGR(instance: *mut c_void, inputs: *const c_void, outputs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_finalize_const_vectorLMatGR(instance: *mut c_void, inputs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_run_const_vectorLMatGR_vectorLMatGR_vectorLMatGR(instance: *mut c_void, inputs: *const c_void, outputs: *mut c_void, internals: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_inputNameToIndex_String(instance: *mut c_void, input_name: *mut c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Layer_outputNameToIndex_const_StringR(instance: *mut c_void, output_name: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Layer_supportBackend_int(instance: *mut c_void, backend_id: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_initHalide_const_vectorLPtrLBackendWrapperGGR(instance: *mut c_void, inputs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initNgraph_const_vectorLPtrLBackendWrapperGGR_const_vectorLPtrLBackendNodeGGR(instance: *mut c_void, inputs: *const c_void, nodes: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initVkCom_const_vectorLPtrLBackendWrapperGGR(instance: *mut c_void, inputs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initWebnn_const_vectorLPtrLBackendWrapperGGR_const_vectorLPtrLBackendNodeGGR(instance: *mut c_void, inputs: *const c_void, nodes: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initCUDA_voidX_const_vectorLPtrLBackendWrapperGGR_const_vectorLPtrLBackendWrapperGGR(instance: *mut c_void, context: *mut c_void, inputs: *const c_void, outputs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initTimVX_voidX_const_vectorLPtrLBackendWrapperGGR_const_vectorLPtrLBackendWrapperGGR_bool(instance: *mut c_void, tim_vx_info: *mut c_void, inputs_wrapper: *const c_void, outputs_wrapper: *const c_void, is_last: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_applyHalideScheduler_const_PtrLBackendNodeGR_const_vectorLMatXGR_const_vectorLMatGR_int(instance: *const c_void, node: *mut c_void, inputs: *const c_void, outputs: *const c_void, target_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_tryAttach_const_PtrLBackendNodeGR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_setActivation_const_PtrLActivationLayerGR(instance: *mut c_void, layer: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_tryFuse_PtrLLayerGR(instance: *mut c_void, top: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_getScaleShift_const_MatR_MatR(instance: *const c_void, scale: *mut c_void, shift: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_getScaleZeropoint_const_floatR_intR(instance: *const c_void, scale: *mut f32, zeropoint: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_unsetAttached(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_getMemoryShapes_const_const_vectorLMatShapeGR_const_int_vectorLMatShapeGR_vectorLMatShapeGR(instance: *const c_void, inputs: *const c_void, required_outputs: i32, outputs: *mut c_void, internals: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_getFLOPS_const_const_vectorLMatShapeGR_const_vectorLMatShapeGR(instance: *const c_void, inputs: *const c_void, outputs: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Layer_updateMemoryShapes_const_vectorLMatShapeGR(instance: *mut c_void, inputs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_Layer(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_Layer_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_setParamsFrom_const_LayerParamsR(instance: *mut c_void, params: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LayerFactory_registerLayer_const_StringR_Constructor(typ: *const c_char, constructor: Option<unsafe extern "C" fn(*mut c_void) -> *mut c_void>, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LayerFactory_unregisterLayer_const_StringR(typ: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LayerFactory_isLayerRegistered_const_stringR(typ: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_LayerFactory_createLayerInstance_const_StringR_LayerParamsR(typ: *const c_char, params: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_LayerParams_getPropBlobs_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_LayerParams_setPropBlobs_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_LayerParams_getPropName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_LayerParams_setPropName_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_LayerParams_getPropType_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_LayerParams_setPropType_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_LogLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_MVNLayer_getPropEps_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_MVNLayer_setPropEps_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_MVNLayer_getPropNormVariance_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_MVNLayer_setPropNormVariance_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_MVNLayer_getPropAcrossChannels_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_MVNLayer_setPropAcrossChannels_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_MVNLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_MaxUnpoolLayer_getPropPoolKernel_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_setPropPoolKernel_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_getPropPoolPad_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_setPropPoolPad_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_getPropPoolStride_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_setPropPoolStride_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_MishLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_Model(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_Model_const_ModelR(unnamed: *const c_void) -> *mut c_void;
		pub fn cv_dnn_Model_Model_ModelRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Model_Model_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_Model_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputSize_const_SizeR(instance: *mut c_void, size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputSize_int_int(instance: *mut c_void, width: i32, height: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputMean_const_ScalarR(instance: *mut c_void, mean: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputScale_double(instance: *mut c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputCrop_bool(instance: *mut c_void, crop: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputSwapRB_bool(instance: *mut c_void, swap_rb: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputParams_double_const_SizeR_const_ScalarR_bool_bool(instance: *mut c_void, scale: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Model_predict_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, frame: *const c_void, outs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Model_setPreferableBackend_Backend(instance: *mut c_void, backend_id: crate::dnn::Backend, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setPreferableTarget_Target(instance: *mut c_void, target_id: crate::dnn::Target, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_getNetwork__const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_getNetwork_(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_Net(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_readFromModelOptimizer_const_StringR_const_StringR(xml: *const c_char, bin: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_readFromModelOptimizer_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(buffer_model_config: *const c_void, buffer_weights: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_readFromModelOptimizer_const_unsigned_charX_size_t_const_unsigned_charX_size_t(buffer_model_config_ptr: *const u8, buffer_model_config_size: size_t, buffer_weights_ptr: *const u8, buffer_weights_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Net_dump(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_dumpToFile_const_StringR(instance: *mut c_void, path: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_addLayer_const_StringR_const_StringR_const_intR_LayerParamsR(instance: *mut c_void, name: *const c_char, typ: *const c_char, dtype: *const i32, params: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_addLayer_const_StringR_const_StringR_LayerParamsR(instance: *mut c_void, name: *const c_char, typ: *const c_char, params: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_addLayerToPrev_const_StringR_const_StringR_const_intR_LayerParamsR(instance: *mut c_void, name: *const c_char, typ: *const c_char, dtype: *const i32, params: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_addLayerToPrev_const_StringR_const_StringR_LayerParamsR(instance: *mut c_void, name: *const c_char, typ: *const c_char, params: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_getLayerId_const_const_StringR(instance: *const c_void, layer: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_getLayerNames_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getLayer_const_int(instance: *const c_void, layer_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getLayer_const_const_StringR(instance: *const c_void, layer_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getLayer_const_const_LayerIdR(instance: *const c_void, layer_id: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getLayerInputs_const_int(instance: *const c_void, layer_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_connect_String_String(instance: *mut c_void, out_pin: *mut c_char, inp_pin: *mut c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_connect_int_int_int_int(instance: *mut c_void, out_layer_id: i32, out_num: i32, inp_layer_id: i32, inp_num: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_registerOutput_const_stringR_int_int(instance: *mut c_void, output_name: *const c_char, layer_id: i32, output_port: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_setInputsNames_const_vectorLStringGR(instance: *mut c_void, input_blob_names: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setInputShape_const_StringR_const_MatShapeR(instance: *mut c_void, input_name: *const c_char, shape: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_forward_const_StringR(instance: *mut c_void, output_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_forwardAsync_const_StringR(instance: *mut c_void, output_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_forward_const__OutputArrayR_const_StringR(instance: *mut c_void, output_blobs: *const c_void, output_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_forward_const__OutputArrayR_const_vectorLStringGR(instance: *mut c_void, output_blobs: *const c_void, out_blob_names: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_forward_vectorLvectorLMatGGR_const_vectorLStringGR(instance: *mut c_void, output_blobs: *mut c_void, out_blob_names: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_quantize_const__InputArrayR_int_int(instance: *mut c_void, calib_data: *const c_void, inputs_dtype: i32, outputs_dtype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getInputDetails_const_vectorLfloatGR_vectorLintGR(instance: *const c_void, scales: *mut c_void, zeropoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getOutputDetails_const_vectorLfloatGR_vectorLintGR(instance: *const c_void, scales: *mut c_void, zeropoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setHalideScheduler_const_StringR(instance: *mut c_void, scheduler: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setPreferableBackend_int(instance: *mut c_void, backend_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setPreferableTarget_int(instance: *mut c_void, target_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setInput_const__InputArrayR_const_StringR_double_const_ScalarR(instance: *mut c_void, blob: *const c_void, name: *const c_char, scalefactor: f64, mean: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setParam_int_int_const_MatR(instance: *mut c_void, layer: i32, num_param: i32, blob: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setParam_const_StringR_int_const_MatR(instance: *mut c_void, layer_name: *const c_char, num_param: i32, blob: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getParam_const_int_int(instance: *const c_void, layer: i32, num_param: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getParam_const_const_StringR_int(instance: *const c_void, layer_name: *const c_char, num_param: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getUnconnectedOutLayers_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getUnconnectedOutLayersNames_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getLayersShapes_const_const_vectorLMatShapeGR_vectorLintGR_vectorLvectorLMatShapeGGR_vectorLvectorLMatShapeGGR(instance: *const c_void, net_input_shapes: *const c_void, layers_ids: *mut c_void, in_layers_shapes: *mut c_void, out_layers_shapes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getLayersShapes_const_const_MatShapeR_vectorLintGR_vectorLvectorLMatShapeGGR_vectorLvectorLMatShapeGGR(instance: *const c_void, net_input_shape: *const c_void, layers_ids: *mut c_void, in_layers_shapes: *mut c_void, out_layers_shapes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getLayerShapes_const_const_MatShapeR_const_int_vectorLMatShapeGR_vectorLMatShapeGR(instance: *const c_void, net_input_shape: *const c_void, layer_id: i32, in_layer_shapes: *mut c_void, out_layer_shapes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getLayerShapes_const_const_vectorLMatShapeGR_const_int_vectorLMatShapeGR_vectorLMatShapeGR(instance: *const c_void, net_input_shapes: *const c_void, layer_id: i32, in_layer_shapes: *mut c_void, out_layer_shapes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getFLOPS_const_const_vectorLMatShapeGR(instance: *const c_void, net_input_shapes: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Net_getFLOPS_const_const_MatShapeR(instance: *const c_void, net_input_shape: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Net_getFLOPS_const_const_int_const_vectorLMatShapeGR(instance: *const c_void, layer_id: i32, net_input_shapes: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Net_getFLOPS_const_const_int_const_MatShapeR(instance: *const c_void, layer_id: i32, net_input_shape: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Net_getLayerTypes_const_vectorLStringGR(instance: *const c_void, layers_types: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getLayersCount_const_const_StringR(instance: *const c_void, layer_type: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_vectorLMatShapeGR_size_tR_size_tR(instance: *const c_void, net_input_shapes: *const c_void, weights: *mut size_t, blobs: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_MatShapeR_size_tR_size_tR(instance: *const c_void, net_input_shape: *const c_void, weights: *mut size_t, blobs: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_int_const_vectorLMatShapeGR_size_tR_size_tR(instance: *const c_void, layer_id: i32, net_input_shapes: *const c_void, weights: *mut size_t, blobs: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_int_const_MatShapeR_size_tR_size_tR(instance: *const c_void, layer_id: i32, net_input_shape: *const c_void, weights: *mut size_t, blobs: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_vectorLMatShapeGR_vectorLintGR_vectorLsize_tGR_vectorLsize_tGR(instance: *const c_void, net_input_shapes: *const c_void, layer_ids: *mut c_void, weights: *mut c_void, blobs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_MatShapeR_vectorLintGR_vectorLsize_tGR_vectorLsize_tGR(instance: *const c_void, net_input_shape: *const c_void, layer_ids: *mut c_void, weights: *mut c_void, blobs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_enableFusion_bool(instance: *mut c_void, fusion: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getPerfProfile_vectorLdoubleGR(instance: *mut c_void, timings: *mut c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_NormalizeBBoxLayer_getPropPnorm_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_NormalizeBBoxLayer_setPropPnorm_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_NormalizeBBoxLayer_getPropEpsilon_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_NormalizeBBoxLayer_setPropEpsilon_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_NormalizeBBoxLayer_getPropAcrossSpatial_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_NormalizeBBoxLayer_setPropAcrossSpatial_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_NormalizeBBoxLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_NotLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PaddingLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PermuteLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PoolingLayer_getPropType_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_PoolingLayer_setPropType_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_PoolingLayer_getPropKernel_size_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_setPropKernel_size_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_PoolingLayer_getPropStrides_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_setPropStrides_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_PoolingLayer_getPropPads_begin_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_setPropPads_begin_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_PoolingLayer_getPropPads_end_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_setPropPads_end_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_PoolingLayer_getPropGlobalPooling_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_PoolingLayer_setPropGlobalPooling_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_PoolingLayer_getPropIsGlobalPooling_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_setPropIsGlobalPooling_vectorLboolG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_PoolingLayer_getPropComputeMaxIdx_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_PoolingLayer_setPropComputeMaxIdx_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_PoolingLayer_getPropPadMode_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_setPropPadMode_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_PoolingLayer_getPropCeilMode_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_PoolingLayer_setPropCeilMode_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_PoolingLayer_getPropAvePoolPaddedArea_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_PoolingLayer_setPropAvePoolPaddedArea_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_PoolingLayer_getPropPooledSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_PoolingLayer_setPropPooledSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_PoolingLayer_getPropSpatialScale_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PoolingLayer_setPropSpatialScale_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PoolingLayer_getPropPsRoiOutChannels_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_PoolingLayer_setPropPsRoiOutChannels_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_PoolingLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PoolingLayerInt8_getPropInput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_PoolingLayerInt8_setPropInput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_PoolingLayerInt8_getPropOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_PoolingLayerInt8_setPropOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_PoolingLayerInt8_getPropInput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PoolingLayerInt8_setPropInput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PoolingLayerInt8_getPropOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PoolingLayerInt8_setPropOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PoolingLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PowerLayer_getPropPower_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PowerLayer_setPropPower_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PowerLayer_getPropScale_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PowerLayer_setPropScale_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PowerLayer_getPropShift_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PowerLayer_setPropShift_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PowerLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PriorBoxLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ProposalLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_QuantizeLayer_getPropScale_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_QuantizeLayer_setPropScale_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_QuantizeLayer_getPropZeropoint_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_QuantizeLayer_setPropZeropoint_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_QuantizeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_RNNLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_RNNLayer_setWeights_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR(instance: *mut c_void, wxh: *const c_void, bh: *const c_void, whh: *const c_void, who: *const c_void, bo: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_RNNLayer_setProduceHiddenOutput_bool(instance: *mut c_void, produce: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_ReLU6Layer_getPropMinValue_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ReLU6Layer_setPropMinValue_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ReLU6Layer_getPropMaxValue_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ReLU6Layer_setPropMaxValue_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ReLU6Layer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReLULayer_getPropNegativeSlope_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ReLULayer_setPropNegativeSlope_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ReLULayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReciprocalLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReduceLayer_getPropReduceType_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ReduceLayer_setPropReduceType_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ReduceLayer_getPropReduceDims_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_ReduceLayer_setPropReduceDims_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_ReduceLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReduceLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_RegionLayer_getPropNmsThreshold_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_RegionLayer_setPropNmsThreshold_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_RegionLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReorgLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_RequantizeLayer_getPropScale_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_RequantizeLayer_setPropScale_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_RequantizeLayer_getPropShift_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_RequantizeLayer_setPropShift_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_RequantizeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReshapeLayer_getPropNewShapeDesc_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_ReshapeLayer_setPropNewShapeDesc_MatShape(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_ReshapeLayer_getPropNewShapeRange_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_ReshapeLayer_setPropNewShapeRange_Range(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_ReshapeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ResizeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_RoundLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ScaleLayer_getPropHasBias_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_ScaleLayer_setPropHasBias_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_ScaleLayer_getPropAxis_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ScaleLayer_setPropAxis_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ScaleLayer_getPropMode_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_ScaleLayer_setPropMode_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_ScaleLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ScaleLayerInt8_getPropOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ScaleLayerInt8_setPropOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ScaleLayerInt8_getPropOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ScaleLayerInt8_setPropOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ScaleLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SegmentationModel_SegmentationModel_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SegmentationModel_SegmentationModel_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SegmentationModel_segment_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, frame: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_SeluLayer_getPropAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_SeluLayer_setPropAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_SeluLayer_getPropGamma_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_SeluLayer_setPropGamma_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_SeluLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ShiftLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ShiftLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ShrinkLayer_getPropBias_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ShrinkLayer_setPropBias_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ShrinkLayer_getPropLambd_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ShrinkLayer_setPropLambd_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ShrinkLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ShuffleChannelLayer_getPropGroup_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ShuffleChannelLayer_setPropGroup_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ShuffleChannelLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SigmoidLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SignLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SinLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SinhLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SliceLayer_getPropSliceRanges_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_SliceLayer_setPropSliceRanges_vectorLvectorLRangeGG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_SliceLayer_getPropSliceSteps_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_SliceLayer_setPropSliceSteps_vectorLvectorLintGG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_SliceLayer_getPropAxis_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_SliceLayer_setPropAxis_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_SliceLayer_getPropNum_split_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_SliceLayer_setPropNum_split_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_SliceLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SoftmaxLayer_getPropLogSoftMax_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_SoftmaxLayer_setPropLogSoftMax_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_SoftmaxLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SoftmaxLayerInt8_getPropOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_SoftmaxLayerInt8_setPropOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_SoftmaxLayerInt8_getPropOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_SoftmaxLayerInt8_setPropOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_SoftmaxLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SoftplusLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SoftsignLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SplitLayer_getPropOutputsCount_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_SplitLayer_setPropOutputsCount_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_SplitLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SqrtLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SwishLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TanHLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TanLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_detect_const_const__InputArrayR_vectorLvectorLPointGGR_vectorLfloatGR(instance: *const c_void, frame: *const c_void, detections: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_TextDetectionModel_detect_const_const__InputArrayR_vectorLvectorLPointGGR(instance: *const c_void, frame: *const c_void, detections: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_TextDetectionModel_detectTextRectangles_const_const__InputArrayR_vectorLRotatedRectGR_vectorLfloatGR(instance: *const c_void, frame: *const c_void, detections: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_TextDetectionModel_detectTextRectangles_const_const__InputArrayR_vectorLRotatedRectGR(instance: *const c_void, frame: *const c_void, detections: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_TextDetectionModel_DB_TextDetectionModel_DB(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_TextDetectionModel_DB_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_TextDetectionModel_DB_const_stringR_const_stringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_setBinaryThreshold_float(instance: *mut c_void, binary_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_getBinaryThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_dnn_TextDetectionModel_DB_setPolygonThreshold_float(instance: *mut c_void, polygon_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_getPolygonThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_dnn_TextDetectionModel_DB_setUnclipRatio_double(instance: *mut c_void, unclip_ratio: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_getUnclipRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_dnn_TextDetectionModel_DB_setMaxCandidates_int(instance: *mut c_void, max_candidates: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_getMaxCandidates_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_TextDetectionModel_EAST_TextDetectionModel_EAST(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_TextDetectionModel_EAST_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_TextDetectionModel_EAST_const_stringR_const_stringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_setConfidenceThreshold_float(instance: *mut c_void, conf_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_getConfidenceThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_dnn_TextDetectionModel_EAST_setNMSThreshold_float(instance: *mut c_void, nms_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_getNMSThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_dnn_TextRecognitionModel_TextRecognitionModel(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_TextRecognitionModel_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_TextRecognitionModel_const_stringR_const_stringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_setDecodeType_const_stringR(instance: *mut c_void, decode_type: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_getDecodeType_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_setDecodeOptsCTCPrefixBeamSearch_int_int(instance: *mut c_void, beam_size: i32, voc_prune_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_setVocabulary_const_vectorLstringGR(instance: *mut c_void, vocabulary: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_getVocabulary_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_recognize_const_const__InputArrayR(instance: *const c_void, frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_recognize_const_const__InputArrayR_const__InputArrayR_vectorLstringGR(instance: *const c_void, frame: *const c_void, roi_rects: *const c_void, results: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_ThresholdedReluLayer_getPropAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ThresholdedReluLayer_setPropAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ThresholdedReluLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn__Range__Range_const_RangeR(r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn__Range__Range_int_int(start_: i32, size_: i32, ocvrs_return: *mut Result<*mut c_void>);
	}
}
#[cfg(ocvrs_has_module_dnn)]
pub use dnn_sys::*;

#[cfg(ocvrs_has_module_features2d)]
mod features2d_sys {
	use super::*;

	extern "C" {
		pub fn cv_AGAST_const__InputArrayR_vectorLKeyPointGR_int_bool(image: *const c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, ocvrs_return: *mut Result_void);
		pub fn cv_AGAST_const__InputArrayR_vectorLKeyPointGR_int_bool_DetectorType(image: *const c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, typ: crate::features2d::AgastFeatureDetector_DetectorType, ocvrs_return: *mut Result_void);
		pub fn cv_FAST_const__InputArrayR_vectorLKeyPointGR_int_bool(image: *const c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, ocvrs_return: *mut Result_void);
		pub fn cv_FAST_const__InputArrayR_vectorLKeyPointGR_int_bool_DetectorType(image: *const c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, typ: crate::features2d::FastFeatureDetector_DetectorType, ocvrs_return: *mut Result_void);
		pub fn cv_computeRecallPrecisionCurve_const_vectorLvectorLDMatchGGR_const_vectorLvectorLunsigned_charGGR_vectorLPoint2fGR(matches1to2: *const c_void, correct_matches1to2_mask: *const c_void, recall_precision_curve: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_drawKeypoints_const__InputArrayR_const_vectorLKeyPointGR_const__InputOutputArrayR_const_ScalarR_DrawMatchesFlags(image: *const c_void, keypoints: *const c_void, out_image: *const c_void, color: *const core::Scalar, flags: crate::features2d::DrawMatchesFlags, ocvrs_return: *mut Result_void);
		pub fn cv_drawMatches_const__InputArrayR_const_vectorLKeyPointGR_const__InputArrayR_const_vectorLKeyPointGR_const_vectorLDMatchGR_const__InputOutputArrayR_const_ScalarR_const_ScalarR_const_vectorLcharGR_DrawMatchesFlags(img1: *const c_void, keypoints1: *const c_void, img2: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, out_img: *const c_void, match_color: *const core::Scalar, single_point_color: *const core::Scalar, matches_mask: *const c_void, flags: crate::features2d::DrawMatchesFlags, ocvrs_return: *mut Result_void);
		pub fn cv_drawMatches_const__InputArrayR_const_vectorLKeyPointGR_const__InputArrayR_const_vectorLKeyPointGR_const_vectorLDMatchGR_const__InputOutputArrayR_const_int_const_ScalarR_const_ScalarR_const_vectorLcharGR_DrawMatchesFlags(img1: *const c_void, keypoints1: *const c_void, img2: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, out_img: *const c_void, matches_thickness: i32, match_color: *const core::Scalar, single_point_color: *const core::Scalar, matches_mask: *const c_void, flags: crate::features2d::DrawMatchesFlags, ocvrs_return: *mut Result_void);
		pub fn cv_drawMatches_const__InputArrayR_const_vectorLKeyPointGR_const__InputArrayR_const_vectorLKeyPointGR_const_vectorLvectorLDMatchGGR_const__InputOutputArrayR_const_ScalarR_const_ScalarR_const_vectorLvectorLcharGGR_DrawMatchesFlags(img1: *const c_void, keypoints1: *const c_void, img2: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, out_img: *const c_void, match_color: *const core::Scalar, single_point_color: *const core::Scalar, matches_mask: *const c_void, flags: crate::features2d::DrawMatchesFlags, ocvrs_return: *mut Result_void);
		pub fn cv_evaluateFeatureDetector_const_MatR_const_MatR_const_MatR_vectorLKeyPointGX_vectorLKeyPointGX_floatR_intR_const_PtrLFeature2DGR(img1: *const c_void, img2: *const c_void, h1to2: *const c_void, keypoints1: *mut c_void, keypoints2: *mut c_void, repeatability: *mut f32, corresp_count: *mut i32, fdetector: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_getNearestPoint_const_vectorLPoint2fGR_float(recall_precision_curve: *const c_void, l_precision: f32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getRecall_const_vectorLPoint2fGR_float(recall_precision_curve: *const c_void, l_precision: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_AKAZE_create_DescriptorType_int_int_float_int_int_DiffusivityType(descriptor_type: crate::features2d::AKAZE_DescriptorType, descriptor_size: i32, descriptor_channels: i32, threshold: f32, n_octaves: i32, n_octave_layers: i32, diffusivity: crate::features2d::KAZE_DiffusivityType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AKAZE_setDescriptorType_DescriptorType(instance: *mut c_void, dtype: crate::features2d::AKAZE_DescriptorType, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getDescriptorType_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::AKAZE_DescriptorType>);
		pub fn cv_AKAZE_setDescriptorSize_int(instance: *mut c_void, dsize: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getDescriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AKAZE_setDescriptorChannels_int(instance: *mut c_void, dch: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getDescriptorChannels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AKAZE_setThreshold_double(instance: *mut c_void, threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_AKAZE_setNOctaves_int(instance: *mut c_void, octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getNOctaves_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AKAZE_setNOctaveLayers_int(instance: *mut c_void, octave_layers: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getNOctaveLayers_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AKAZE_setDiffusivity_DiffusivityType(instance: *mut c_void, diff: crate::features2d::KAZE_DiffusivityType, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getDiffusivity_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::KAZE_DiffusivityType>);
		pub fn cv_AKAZE_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AffineFeature_create_const_PtrLFeature2DGR_int_int_float_float(backend: *const c_void, max_tilt: i32, min_tilt: i32, tilt_step: f32, rotate_step_base: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AffineFeature_setViewParams_const_vectorLfloatGR_const_vectorLfloatGR(instance: *mut c_void, tilts: *const c_void, rolls: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AffineFeature_getViewParams_const_vectorLfloatGR_vectorLfloatGR(instance: *const c_void, tilts: *mut c_void, rolls: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AffineFeature_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AgastFeatureDetector_create_int_bool_DetectorType(threshold: i32, nonmax_suppression: bool, typ: crate::features2d::AgastFeatureDetector_DetectorType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AgastFeatureDetector_setThreshold_int(instance: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AgastFeatureDetector_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AgastFeatureDetector_setNonmaxSuppression_bool(instance: *mut c_void, f: bool, ocvrs_return: *mut Result_void);
		pub fn cv_AgastFeatureDetector_getNonmaxSuppression_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_AgastFeatureDetector_setType_DetectorType(instance: *mut c_void, typ: crate::features2d::AgastFeatureDetector_DetectorType, ocvrs_return: *mut Result_void);
		pub fn cv_AgastFeatureDetector_getType_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::AgastFeatureDetector_DetectorType>);
		pub fn cv_AgastFeatureDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BFMatcher_BFMatcher_int_bool(norm_type: i32, cross_check: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BFMatcher_isMaskSupported_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BFMatcher_create_int_bool(norm_type: i32, cross_check: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BFMatcher_clone_const_bool(instance: *const c_void, empty_train_data: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor_const_PtrLFeature2DGR_const_PtrLDescriptorMatcherGR(dextractor: *const c_void, dmatcher: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor_const_PtrLDescriptorMatcherGR(dmatcher: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWImgDescriptorExtractor_setVocabulary_const_MatR(instance: *mut c_void, vocabulary: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWImgDescriptorExtractor_getVocabulary_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWImgDescriptorExtractor_compute_const__InputArrayR_vectorLKeyPointGR_const__OutputArrayR_vectorLvectorLintGGX_MatX(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, img_descriptor: *const c_void, point_idxs_of_clusters: *mut c_void, descriptors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWImgDescriptorExtractor_compute_const__InputArrayR_const__OutputArrayR_vectorLvectorLintGGX(instance: *mut c_void, keypoint_descriptors: *const c_void, img_descriptor: *const c_void, point_idxs_of_clusters: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWImgDescriptorExtractor_compute2_const_MatR_vectorLKeyPointGR_MatR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, img_descriptor: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWImgDescriptorExtractor_descriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BOWImgDescriptorExtractor_descriptorType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BOWKMeansTrainer_BOWKMeansTrainer_int_const_TermCriteriaR_int_int(cluster_count: i32, termcrit: *const core::TermCriteria, attempts: i32, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWKMeansTrainer_cluster_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWKMeansTrainer_cluster_const_const_MatR(instance: *const c_void, descriptors: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWTrainer_add_const_MatR(instance: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWTrainer_getDescriptors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWTrainer_descriptorsCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BOWTrainer_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWTrainer_cluster_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWTrainer_cluster_const_const_MatR(instance: *const c_void, descriptors: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_create_int_int_float(thresh: i32, octaves: i32, pattern_scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_create_const_vectorLfloatGR_const_vectorLintGR_float_float_const_vectorLintGR(radius_list: *const c_void, number_list: *const c_void, d_max: f32, d_min: f32, index_change: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_create_int_int_const_vectorLfloatGR_const_vectorLintGR_float_float_const_vectorLintGR(thresh: i32, octaves: i32, radius_list: *const c_void, number_list: *const c_void, d_max: f32, d_min: f32, index_change: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_setThreshold_int(instance: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BRISK_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BRISK_setOctaves_int(instance: *mut c_void, octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BRISK_getOctaves_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DescriptorMatcher_add_const__InputArrayR(instance: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_getTrainDescriptors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DescriptorMatcher_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DescriptorMatcher_isMaskSupported_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DescriptorMatcher_train(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_match_const_const__InputArrayR_const__InputArrayR_vectorLDMatchGR_const__InputArrayR(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_knnMatch_const_const__InputArrayR_const__InputArrayR_vectorLvectorLDMatchGGR_int_const__InputArrayR_bool(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, k: i32, mask: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_radiusMatch_const_const__InputArrayR_const__InputArrayR_vectorLvectorLDMatchGGR_float_const__InputArrayR_bool(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, mask: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_match_const__InputArrayR_vectorLDMatchGR_const__InputArrayR(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_knnMatch_const__InputArrayR_vectorLvectorLDMatchGGR_int_const__InputArrayR_bool(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, k: i32, masks: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_radiusMatch_const__InputArrayR_vectorLvectorLDMatchGGR_float_const__InputArrayR_bool(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, masks: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_write_const_const_StringR(instance: *const c_void, file_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_read_const_StringR(instance: *mut c_void, file_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_read_const_FileNodeR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_write_const_FileStorageR(instance: *const c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_clone_const_bool(instance: *const c_void, empty_train_data: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DescriptorMatcher_create_const_StringR(descriptor_matcher_type: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DescriptorMatcher_create_const_MatcherTypeR(matcher_type: *const crate::features2d::DescriptorMatcher_MatcherType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DescriptorMatcher_write_const_const_PtrLFileStorageGR_const_StringR(instance: *const c_void, fs: *const c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_FastFeatureDetector_create_int_bool_DetectorType(threshold: i32, nonmax_suppression: bool, typ: crate::features2d::FastFeatureDetector_DetectorType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FastFeatureDetector_setThreshold_int(instance: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FastFeatureDetector_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FastFeatureDetector_setNonmaxSuppression_bool(instance: *mut c_void, f: bool, ocvrs_return: *mut Result_void);
		pub fn cv_FastFeatureDetector_getNonmaxSuppression_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FastFeatureDetector_setType_DetectorType(instance: *mut c_void, typ: crate::features2d::FastFeatureDetector_DetectorType, ocvrs_return: *mut Result_void);
		pub fn cv_FastFeatureDetector_getType_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::FastFeatureDetector_DetectorType>);
		pub fn cv_FastFeatureDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Feature2D_detect_const__InputArrayR_vectorLKeyPointGR_const__InputArrayR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_detect_const__InputArrayR_vectorLvectorLKeyPointGGR_const__InputArrayR(instance: *mut c_void, images: *const c_void, keypoints: *mut c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_compute_const__InputArrayR_vectorLKeyPointGR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_compute_const__InputArrayR_vectorLvectorLKeyPointGGR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_detectAndCompute_const__InputArrayR_const__InputArrayR_vectorLKeyPointGR_const__OutputArrayR_bool(instance: *mut c_void, image: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, use_provided_keypoints: bool, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_descriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Feature2D_descriptorType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Feature2D_defaultNorm_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Feature2D_write_const_const_StringR(instance: *const c_void, file_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_read_const_StringR(instance: *mut c_void, file_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_write_const_FileStorageR(instance: *const c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_read_const_FileNodeR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Feature2D_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Feature2D_write_const_const_PtrLFileStorageGR_const_StringR(instance: *const c_void, fs: *const c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_FlannBasedMatcher_const_PtrLIndexParamsGR_const_PtrLSearchParamsGR(index_params: *const c_void, search_params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FlannBasedMatcher_add_const__InputArrayR(instance: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_read_const_FileNodeR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_write_const_FileStorageR(instance: *const c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_train(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_isMaskSupported_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FlannBasedMatcher_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FlannBasedMatcher_clone_const_bool(instance: *const c_void, empty_train_data: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFTTDetector_create_int_double_double_int_bool_double(max_corners: i32, quality_level: f64, min_distance: f64, block_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFTTDetector_create_int_double_double_int_int_bool_double(max_corners: i32, quality_level: f64, min_distance: f64, block_size: i32, gradiant_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFTTDetector_setMaxFeatures_int(instance: *mut c_void, max_features: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getMaxFeatures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GFTTDetector_setQualityLevel_double(instance: *mut c_void, qlevel: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getQualityLevel_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GFTTDetector_setMinDistance_double(instance: *mut c_void, min_distance: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getMinDistance_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GFTTDetector_setBlockSize_int(instance: *mut c_void, block_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GFTTDetector_setHarrisDetector_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getHarrisDetector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GFTTDetector_setK_double(instance: *mut c_void, k: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getK_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GFTTDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KAZE_create_bool_bool_float_int_int_DiffusivityType(extended: bool, upright: bool, threshold: f32, n_octaves: i32, n_octave_layers: i32, diffusivity: crate::features2d::KAZE_DiffusivityType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KAZE_setExtended_bool(instance: *mut c_void, extended: bool, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getExtended_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_KAZE_setUpright_bool(instance: *mut c_void, upright: bool, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getUpright_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_KAZE_setThreshold_double(instance: *mut c_void, threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_KAZE_setNOctaves_int(instance: *mut c_void, octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getNOctaves_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_KAZE_setNOctaveLayers_int(instance: *mut c_void, octave_layers: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getNOctaveLayers_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_KAZE_setDiffusivity_DiffusivityType(instance: *mut c_void, diff: crate::features2d::KAZE_DiffusivityType, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getDiffusivity_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::KAZE_DiffusivityType>);
		pub fn cv_KAZE_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPointsFilter_KeyPointsFilter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPointsFilter_runByImageBorder_vectorLKeyPointGR_Size_int(keypoints: *mut c_void, image_size: *const core::Size, border_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_runByKeypointSize_vectorLKeyPointGR_float_float(keypoints: *mut c_void, min_size: f32, max_size: f32, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_runByPixelsMask_vectorLKeyPointGR_const_MatR(keypoints: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_removeDuplicated_vectorLKeyPointGR(keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_removeDuplicatedSorted_vectorLKeyPointGR(keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_retainBest_vectorLKeyPointGR_int(keypoints: *mut c_void, npoints: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_create_int_int_int_double_double_int_double_double_int(delta: i32, min_area: i32, max_area: i32, max_variation: f64, min_diversity: f64, max_evolution: i32, area_threshold: f64, min_margin: f64, edge_blur_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MSER_detectRegions_const__InputArrayR_vectorLvectorLPointGGR_vectorLRectGR(instance: *mut c_void, image: *const c_void, msers: *mut c_void, bboxes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_setDelta_int(instance: *mut c_void, delta: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getDelta_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MSER_setMinArea_int(instance: *mut c_void, min_area: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getMinArea_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MSER_setMaxArea_int(instance: *mut c_void, max_area: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getMaxArea_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MSER_setPass2Only_bool(instance: *mut c_void, f: bool, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getPass2Only_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_MSER_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ORB_create_int_float_int_int_int_int_ScoreType_int_int(nfeatures: i32, scale_factor: f32, nlevels: i32, edge_threshold: i32, first_level: i32, wta_k: i32, score_type: crate::features2d::ORB_ScoreType, patch_size: i32, fast_threshold: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ORB_setMaxFeatures_int(instance: *mut c_void, max_features: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getMaxFeatures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setScaleFactor_double(instance: *mut c_void, scale_factor: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ORB_setNLevels_int(instance: *mut c_void, nlevels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getNLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setEdgeThreshold_int(instance: *mut c_void, edge_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getEdgeThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setFirstLevel_int(instance: *mut c_void, first_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getFirstLevel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setWTA_K_int(instance: *mut c_void, wta_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getWTA_K_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setScoreType_ScoreType(instance: *mut c_void, score_type: crate::features2d::ORB_ScoreType, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getScoreType_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::ORB_ScoreType>);
		pub fn cv_ORB_setPatchSize_int(instance: *mut c_void, patch_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getPatchSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setFastThreshold_int(instance: *mut c_void, fast_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getFastThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SIFT_create_int_int_double_double_double(nfeatures: i32, n_octave_layers: i32, contrast_threshold: f64, edge_threshold: f64, sigma: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SIFT_create_int_int_double_double_double_int(nfeatures: i32, n_octave_layers: i32, contrast_threshold: f64, edge_threshold: f64, sigma: f64, descriptor_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SIFT_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SimpleBlobDetector_create_const_ParamsR(parameters: *const crate::features2d::SimpleBlobDetector_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SimpleBlobDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SimpleBlobDetector_Params_Params(ocvrs_return: *mut Result<crate::features2d::SimpleBlobDetector_Params>);
		pub fn cv_SimpleBlobDetector_Params_read_const_FileNodeR(instance: *const crate::features2d::SimpleBlobDetector_Params, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SimpleBlobDetector_Params_write_const_FileStorageR(instance: *const crate::features2d::SimpleBlobDetector_Params, fs: *mut c_void, ocvrs_return: *mut Result_void);
	}
}
#[cfg(ocvrs_has_module_features2d)]
pub use features2d_sys::*;

#[cfg(ocvrs_has_module_flann)]
mod flann_sys {
	use super::*;

	extern "C" {
		pub fn cvflann_flann_distance_type(ocvrs_return: *mut Result<crate::flann::flann_distance_t>);
		pub fn cvflann_set_distance_type_flann_distance_t_int(distance_type: crate::flann::flann_distance_t, order: i32, ocvrs_return: *mut Result_void);
		pub fn cv_flann_AutotunedIndexParams_AutotunedIndexParams_float_float_float_float(target_precision: f32, build_weight: f32, memory_weight: f32, sample_fraction: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_CompositeIndexParams_CompositeIndexParams_int_int_int_flann_centers_init_t_float(trees: i32, branching: i32, iterations: i32, centers_init: crate::flann::flann_centers_init_t, cb_index: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_HierarchicalClusteringIndexParams_HierarchicalClusteringIndexParams_int_flann_centers_init_t_int_int(branching: i32, centers_init: crate::flann::flann_centers_init_t, trees: i32, leaf_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_Index_Index(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_Index_Index_const__InputArrayR_const_IndexParamsR_flann_distance_t(features: *const c_void, params: *const c_void, dist_type: crate::flann::flann_distance_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_Index_build_const__InputArrayR_const_IndexParamsR_flann_distance_t(instance: *mut c_void, features: *const c_void, params: *const c_void, dist_type: crate::flann::flann_distance_t, ocvrs_return: *mut Result_void);
		pub fn cv_flann_Index_knnSearch_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_const_SearchParamsR(instance: *mut c_void, query: *const c_void, indices: *const c_void, dists: *const c_void, knn: i32, params: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_flann_Index_radiusSearch_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_int_const_SearchParamsR(instance: *mut c_void, query: *const c_void, indices: *const c_void, dists: *const c_void, radius: f64, max_results: i32, params: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_flann_Index_save_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_flann_Index_load_const__InputArrayR_const_StringR(instance: *mut c_void, features: *const c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_flann_Index_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_flann_Index_getDistance_const(instance: *const c_void, ocvrs_return: *mut Result<crate::flann::flann_distance_t>);
		pub fn cv_flann_Index_getAlgorithm_const(instance: *const c_void, ocvrs_return: *mut Result<crate::flann::flann_algorithm_t>);
		pub fn cv_flann_IndexParams_getPropParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_IndexParams_setPropParams_voidX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_flann_IndexParams_IndexParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_IndexParams_getString_const_const_StringR_const_StringR(instance: *const c_void, key: *const c_char, default_val: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_IndexParams_getInt_const_const_StringR_int(instance: *const c_void, key: *const c_char, default_val: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_flann_IndexParams_getDouble_const_const_StringR_double(instance: *const c_void, key: *const c_char, default_val: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_flann_IndexParams_setString_const_StringR_const_StringR(instance: *mut c_void, key: *const c_char, value: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_setInt_const_StringR_int(instance: *mut c_void, key: *const c_char, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_setDouble_const_StringR_double(instance: *mut c_void, key: *const c_char, value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_setFloat_const_StringR_float(instance: *mut c_void, key: *const c_char, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_setBool_const_StringR_bool(instance: *mut c_void, key: *const c_char, value: bool, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_setAlgorithm_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_getAll_const_vectorLStringGR_vectorLFlannIndexTypeGR_vectorLStringGR_vectorLdoubleGR(instance: *const c_void, names: *mut c_void, types: *mut c_void, str_values: *mut c_void, num_values: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_flann_KDTreeIndexParams_KDTreeIndexParams_int(trees: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_KMeansIndexParams_KMeansIndexParams_int_int_flann_centers_init_t_float(branching: i32, iterations: i32, centers_init: crate::flann::flann_centers_init_t, cb_index: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_LinearIndexParams_LinearIndexParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_LshIndexParams_LshIndexParams_int_int_int(table_number: i32, key_size: i32, multi_probe_level: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_SavedIndexParams_SavedIndexParams_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_SearchParams_SearchParams_int_float_bool_bool(checks: i32, eps: f32, sorted: bool, explore_all_trees: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_SearchParams_SearchParams_int_float_bool(checks: i32, eps: f32, sorted: bool, ocvrs_return: *mut Result<*mut c_void>);
	}
}
#[cfg(ocvrs_has_module_flann)]
pub use flann_sys::*;

#[cfg(ocvrs_has_module_gapi)]
mod gapi_sys {
	use super::*;

	extern "C" {
		pub fn cv_descr_of_const_MatR(mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_descr_of_const_MediaFrameR(frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_descr_of_const_RMatR(mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_descr_of_const_ScalarR(scalar: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_descr_of_const_UMatR(mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_empty_array_desc(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_empty_gopaque_desc(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_empty_scalar_desc(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BGR2Gray_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BGR2I420_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BGR2LUV_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BGR2RGB_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BGR2YUV_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BayerGR2RGB_const_GMatR(src_gr: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_Canny_const_GMatR_double_double_int_bool(image: *const c_void, threshold1: f64, threshold2: f64, aperture_size: i32, l2gradient: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_I4202BGR_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_I4202RGB_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_LUT_const_GMatR_const_MatR(src: *const c_void, lut: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_LUV2BGR_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_Laplacian_const_GMatR_int_int_double_double_int(src: *const c_void, ddepth: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_NV12toBGR_const_GMatR_const_GMatR(src_y: *const c_void, src_uv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_NV12toBGRp_const_GMatR_const_GMatR(src_y: *const c_void, src_uv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_NV12toGray_const_GMatR_const_GMatR(src_y: *const c_void, src_uv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_NV12toRGB_const_GMatR_const_GMatR(src_y: *const c_void, src_uv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_NV12toRGBp_const_GMatR_const_GMatR(src_y: *const c_void, src_uv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2Gray_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2Gray_const_GMatR_float_float_float(src: *const c_void, r_y: f32, g_y: f32, b_y: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2HSV_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2I420_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2Lab_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2YUV422_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2YUV_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_SobelXY_const_GMatR_int_int_int_double_double_int_const_ScalarR(src: *const c_void, ddepth: i32, order: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_Sobel_const_GMatR_int_int_int_int_double_double_int_const_ScalarR(src: *const c_void, ddepth: i32, dx: i32, dy: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_YUV2BGR_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_YUV2RGB_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_absDiffC_const_GMatR_const_GScalarR(src: *const c_void, c: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_absDiff_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_addC_const_GMatR_const_GScalarR_int(src1: *const c_void, c: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_addC_const_GScalarR_const_GMatR_int(c: *const c_void, src1: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_addWeighted_const_GMatR_double_const_GMatR_double_double_int(src1: *const c_void, alpha: f64, src2: *const c_void, beta: f64, gamma: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_add_const_GMatR_const_GMatR_int(src1: *const c_void, src2: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bilateralFilter_const_GMatR_int_double_double_int(src: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, border_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_and_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_and_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_not_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_or_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_or_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_xor_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_xor_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_blur_const_GMatR_const_SizeR_const_PointR_int_const_ScalarR(src: *const c_void, ksize: *const core::Size, anchor: *const core::Point, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_boxFilter_const_GMatR_int_const_SizeR_const_PointR_bool_int_const_ScalarR(src: *const c_void, dtype: i32, ksize: *const core::Size, anchor: *const core::Point, normalize: bool, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cartToPolar_const_GMatR_const_GMatR_bool(x: *const c_void, y: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpEQ_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpEQ_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpGE_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpGE_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpGT_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpGT_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpLE_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpLE_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpLT_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpLT_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpNE_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpNE_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_combine_const_GKernelPackageR_const_GKernelPackageR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_concatHor_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_concatHor_const_vectorLGMatGR(v: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_concatVert_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_concatVert_const_vectorLGMatGR(v: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_convertTo_const_GMatR_int_double_double(src: *const c_void, rdepth: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_copy_const_GFrameR(in_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_copy_const_GMatR(in_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_crop_const_GMatR_const_RectR(src: *const c_void, rect: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_dilate3x3_const_GMatR_int_int_const_ScalarR(src: *const c_void, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_dilate_const_GMatR_const_MatR_const_PointR_int_int_const_ScalarR(src: *const c_void, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_divC_const_GMatR_const_GScalarR_double_int(src: *const c_void, divisor: *const c_void, scale: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_divRC_const_GScalarR_const_GMatR_double_int(divident: *const c_void, src: *const c_void, scale: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_div_const_GMatR_const_GMatR_double_int(src1: *const c_void, src2: *const c_void, scale: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_equalizeHist_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_erode3x3_const_GMatR_int_int_const_ScalarR(src: *const c_void, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_erode_const_GMatR_const_MatR_const_PointR_int_int_const_ScalarR(src: *const c_void, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_filter2D_const_GMatR_int_const_MatR_const_PointR_const_ScalarR_int_const_ScalarR(src: *const c_void, ddepth: i32, kernel: *const c_void, anchor: *const core::Point, delta: *const core::Scalar, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_flip_const_GMatR_int(src: *const c_void, flip_code: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_gaussianBlur_const_GMatR_const_SizeR_double_double_int_const_ScalarR(src: *const c_void, ksize: *const core::Size, sigma_x: f64, sigma_y: f64, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_inRange_const_GMatR_const_GScalarR_const_GScalarR(src: *const c_void, thresh_low: *const c_void, thresh_up: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_integral_const_GMatR_int_int(src: *const c_void, sdepth: i32, sqdepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mask_const_GMatR_const_GMatR(src: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_max_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mean_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_medianBlur_const_GMatR_int(src: *const c_void, ksize: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_merge3_const_GMatR_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, src3: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_merge4_const_GMatR_const_GMatR_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_min_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_morphologyEx_const_GMatR_const_MorphTypes_const_MatR_const_PointR_const_int_const_BorderTypes_const_ScalarR(src: *const c_void, op: crate::imgproc::MorphTypes, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: core::BorderTypes, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mulC_const_GMatR_const_GScalarR_int(src: *const c_void, multiplier: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mulC_const_GMatR_double_int(src: *const c_void, multiplier: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mulC_const_GScalarR_const_GMatR_int(multiplier: *const c_void, src: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mul_const_GMatR_const_GMatR_double_int(src1: *const c_void, src2: *const c_void, scale: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_normInf_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_normL1_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_normL2_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_normalize_const_GMatR_double_double_int_int(src: *const c_void, alpha: f64, beta: f64, norm_type: i32, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_phase_const_GMatR_const_GMatR_bool(x: *const c_void, y: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_polarToCart_const_GMatR_const_GMatR_bool(magnitude: *const c_void, angle: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_remap_const_GMatR_const_MatR_const_MatR_int_int_const_ScalarR(src: *const c_void, map1: *const c_void, map2: *const c_void, interpolation: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_resizeP_const_GMatPR_const_SizeR_int(src: *const c_void, dsize: *const core::Size, interpolation: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_resize_const_GMatR_const_SizeR_double_double_int(src: *const c_void, dsize: *const core::Size, fx: f64, fy: f64, interpolation: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_select_const_GMatR_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_sepFilter_const_GMatR_int_const_MatR_const_MatR_const_PointR_const_ScalarR_int_const_ScalarR(src: *const c_void, ddepth: i32, kernel_x: *const c_void, kernel_y: *const c_void, anchor: *const core::Point, delta: *const core::Scalar, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_split3_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_split4_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_sqrt_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_BGR_const_GFrameR(in_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_UV_const_GFrameR(frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_Y_const_GFrameR(frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_desync_const_GFrameR(f: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_desync_const_GMatR(g: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_kernels(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_subC_const_GMatR_const_GScalarR_int(src: *const c_void, c: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_subRC_const_GScalarR_const_GMatR_int(c: *const c_void, src: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_sub_const_GMatR_const_GMatR_int(src1: *const c_void, src2: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_sum_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_threshold_const_GMatR_const_GScalarR_const_GScalarR_int(src: *const c_void, thresh: *const c_void, maxval: *const c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_threshold_const_GMatR_const_GScalarR_int(src: *const c_void, maxval: *const c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_transpose_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_warpAffine_const_GMatR_const_MatR_const_SizeR_int_int_const_ScalarR(src: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_warpPerspective_const_GMatR_const_MatR_const_SizeR_int_int_const_ScalarR(src: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNOTB_const_GMatR(lhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_GMatR_float(lhs: *const c_void, rhs: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_float_const_GMatR(lhs: f32, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_validate_input_arg_const_GRunArgR(arg: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_validate_input_args_const_GRunArgsR(args: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GArg_getPropKind_const(instance: *const c_void, ocvrs_return: *mut crate::gapi::ArgKind);
		pub fn cv_GArg_setPropKind_ArgKind(instance: *mut c_void, val: crate::gapi::ArgKind);
		pub fn cv_GArg_getPropOpaque_kind_const(instance: *const c_void, ocvrs_return: *mut crate::gapi::OpaqueKind);
		pub fn cv_GArg_setPropOpaque_kind_OpaqueKind(instance: *mut c_void, val: crate::gapi::OpaqueKind);
		pub fn cv_GArg_GArg(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GArrayDesc_operatorEQ_const_const_GArrayDescR(instance: *const c_void, unnamed: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GCall_GCall_const_GKernelR(k: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yield_int(instance: *mut c_void, output: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yieldP_int(instance: *mut c_void, output: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yieldScalar_int(instance: *mut c_void, output: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yieldFrame_int(instance: *mut c_void, output: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_kernel(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_params(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_setArgs_vectorLGArgGRR(instance: *mut c_void, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GCompileArg_getPropTag_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GCompileArg_setPropTag_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_GCompileArg_GCompileArg() -> *mut c_void;
		pub fn cv_GCompiled_GCompiled(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCompiled_operator___Mat_MatR(instance: *mut c_void, in_: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_operator___Mat_ScalarR(instance: *mut c_void, in_: *mut c_void, out: *mut core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_operator___Mat_Mat_MatR(instance: *mut c_void, in1: *mut c_void, in2: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_operator___Mat_Mat_ScalarR(instance: *mut c_void, in1: *mut c_void, in2: *mut c_void, out: *mut core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_operator___const_vectorLMatGR_const_vectorLMatGR(instance: *mut c_void, ins: *const c_void, outs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_operator_bool_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GCompiled_canReshape_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GCompiled_prepareForNewStream(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_GComputation_GMat_GMat(in_: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_GComputation_GMat_GScalar(in_: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_GComputation_GMat_GMat_GMat(in1: *mut c_void, in2: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_GComputation_GMat_GMat_GScalar(in1: *mut c_void, in2: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_GComputation_const_vectorLGMatGR_const_vectorLGMatGR(ins: *const c_void, outs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_apply_const_ExtractArgsCallbackR_GCompileArgsRR(instance: *mut c_void, callback: *const c_void, args: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_apply_const_vectorLMatGR_const_vectorLMatGR_GCompileArgsRR(instance: *mut c_void, ins: *const c_void, outs: *const c_void, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_MatR_GCompileArgsRR(instance: *mut c_void, in_: *mut c_void, out: *mut c_void, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_ScalarR_GCompileArgsRR(instance: *mut c_void, in_: *mut c_void, out: *mut core::Scalar, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_Mat_MatR_GCompileArgsRR(instance: *mut c_void, in1: *mut c_void, in2: *mut c_void, out: *mut c_void, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_Mat_ScalarR_GCompileArgsRR(instance: *mut c_void, in1: *mut c_void, in2: *mut c_void, out: *mut core::Scalar, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_const_vectorLMatGR_vectorLMatGR_GCompileArgsRR(instance: *mut c_void, ins: *const c_void, outs: *mut c_void, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_compileStreaming_GCompileArgsRR(instance: *mut c_void, args: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_compileStreaming_const_ExtractMetaCallbackR_GCompileArgsRR(instance: *mut c_void, callback: *const c_void, args: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFrame_GFrame(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFrameDesc_getPropFmt_const(instance: *const c_void, ocvrs_return: *mut crate::gapi::MediaFormat);
		pub fn cv_GFrameDesc_setPropFmt_MediaFormat(instance: *mut c_void, val: crate::gapi::MediaFormat);
		pub fn cv_GFrameDesc_getPropSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_GFrameDesc_setPropSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_GFrameDesc_operatorEQ_const_const_GFrameDescR(instance: *const c_void, unnamed: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GKernel_getPropName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernel_setPropName_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_GKernel_getPropTag_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernel_setPropTag_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_GKernel_getPropOutShapes_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernel_setPropOutShapes_GShapes(instance: *mut c_void, val: *mut c_void);
		pub fn cv_GKernel_getPropInKinds_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernel_setPropInKinds_GKinds(instance: *mut c_void, val: *mut c_void);
		pub fn cv_GKernelImpl_getPropOpaque_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernelImpl_setPropOpaque_any(instance: *mut c_void, val: *mut c_void);
		pub fn cv_GKernelPackage_include_const_GFunctorR(instance: *mut c_void, functor: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GKernelPackage_size_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_GKernelPackage_get_transformations_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GKernelPackage_get_kernel_ids_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GKernelPackage_remove_const_GBackendR(instance: *mut c_void, backend: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GKernelPackage_includesAPI_const_const_stringR(instance: *const c_void, id: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_GKernelPackage_lookup_const_const_stringR(instance: *const c_void, id: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GKernelPackage_include_const_GBackendR_const_stringR(instance: *mut c_void, backend: *const c_void, kernel_id: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_GKernelPackage_backends_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMat_GMat(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_getPropDepth_const(instance: *const c_void) -> i32;
		pub fn cv_GMatDesc_setPropDepth_int(instance: *mut c_void, val: i32);
		pub fn cv_GMatDesc_getPropChan_const(instance: *const c_void) -> i32;
		pub fn cv_GMatDesc_setPropChan_int(instance: *mut c_void, val: i32);
		pub fn cv_GMatDesc_getPropSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_GMatDesc_setPropSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_GMatDesc_getPropPlanar_const(instance: *const c_void) -> bool;
		pub fn cv_GMatDesc_setPropPlanar_bool(instance: *mut c_void, val: bool);
		pub fn cv_GMatDesc_getPropDims_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GMatDesc_setPropDims_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_GMatDesc_GMatDesc_int_int_Size_bool(d: i32, c: i32, s: *const core::Size, p: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_GMatDesc_int_const_vectorLintGR(d: i32, dd: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_GMatDesc_int_vectorLintGRR(d: i32, dd: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_GMatDesc(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_operatorEQ_const_const_GMatDescR(instance: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GMatDesc_operatorNE_const_const_GMatDescR(instance: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GMatDesc_isND_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GMatDesc_canDescribe_const_const_MatR(instance: *const c_void, mat: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GMatDesc_canDescribe_const_const_RMatR(instance: *const c_void, mat: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GMatDesc_withSizeDelta_const_Size(instance: *const c_void, delta: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_withSizeDelta_const_int_int(instance: *const c_void, dx: i32, dy: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_withSize_const_Size(instance: *const c_void, sz: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_withDepth_const_int(instance: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_withType_const_int_int(instance: *const c_void, ddepth: i32, dchan: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_asPlanar_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_asPlanar_const_int(instance: *const c_void, planes: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_asInterleaved_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GOpaqueDesc_operatorEQ_const_const_GOpaqueDescR(instance: *const c_void, unnamed: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GRunArg_GRunArg(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GRunArg_GRunArg_const_GRunArgR(arg: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GRunArg_GRunArg_GRunArgRR(arg: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GScalar_GScalar(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GScalar_GScalar_const_ScalarR(s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GScalar_GScalar_ScalarRR(s: *mut core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GScalar_GScalar_double(v0: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GScalarDesc_operatorEQ_const_const_GScalarDescR(instance: *const c_void, unnamed: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GScalarDesc_operatorNE_const_const_GScalarDescR(instance: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GStreamingCompiled_GStreamingCompiled(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GStreamingCompiled_setSource_GRunArgsRR(instance: *mut c_void, ins: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GStreamingCompiled_setSource_const_ExtractArgsCallbackR(instance: *mut c_void, callback: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GStreamingCompiled_start(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GStreamingCompiled_stop(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GStreamingCompiled_running_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GStreamingCompiled_operator_bool_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GTransform_getPropDescription_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GTransform_setPropDescription_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_GTypeInfo_getPropShape_const(instance: *const c_void, ocvrs_return: *mut crate::gapi::GShape);
		pub fn cv_GTypeInfo_setPropShape_GShape(instance: *mut c_void, val: crate::gapi::GShape);
		pub fn cv_GTypeInfo_getPropKind_const(instance: *const c_void, ocvrs_return: *mut crate::gapi::OpaqueKind);
		pub fn cv_GTypeInfo_setPropKind_OpaqueKind(instance: *mut c_void, val: crate::gapi::OpaqueKind);
		pub fn cv_MediaFrame_MediaFrame(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MediaFrame_desc_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MediaFrame_blobParams_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MediaFrame_IAdapter_meta_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MediaFrame_IAdapter_blobParams_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MediaFrame_View_View_ViewRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_RMat_RMat() -> *mut c_void;
		pub fn cv_RMat_desc_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RMat_IAdapter_desc_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RMat_View_View() -> *mut c_void;
		pub fn cv_RMat_View_View_ViewRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_RMat_View_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_RMat_View_dims_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RMat_View_cols_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RMat_View_rows_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RMat_View_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RMat_View_depth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RMat_View_chan_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RMat_View_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_RMat_View_step_const_size_t(instance: *const c_void, i: size_t, ocvrs_return: *mut Result<size_t>);
		pub fn cv_RMat_View_steps_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ExtractArgsCallback_operator___const_const_GTypesInfoR(instance: *const c_void, info: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_GBackend_GBackend(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_GBackend_hash_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_gapi_GBackend_operatorEQ_const_const_GBackendR(instance: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_gapi_GFunctor_impl_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_GFunctor_backend_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_GFunctor_id_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_own_Scalar_getPropVal(instance: *mut c_void) -> *mut [f64; 4];
		pub fn cv_gapi_own_Scalar_Scalar() -> *mut c_void;
		pub fn cv_gapi_own_Scalar_Scalar_double(v0: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_own_Scalar_Scalar_double_double_double_double(v0: f64, v1: f64, v2: f64, v3: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_own_Scalar_operator___const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_gapi_own_Scalar_operator___int(instance: *mut c_void, i: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_gapi_own_Scalar_all_double(v0: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_queue_capacity_queue_capacity_size_t(cap: size_t, ocvrs_return: *mut Result<crate::gapi::queue_capacity>);
		pub fn cv_gapi_use_only_getPropPkg_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_use_only_setPropPkg_GKernelPackage(instance: *mut c_void, val: *mut c_void);
		pub fn cv_gapi_wip_draw_Circle_Circle_const_PointR_int_const_ScalarR_int_int_int(center_: *const core::Point, radius_: i32, color_: *const core::Scalar, thick_: i32, lt_: i32, shift_: i32, ocvrs_return: *mut Result<crate::gapi::Circle>);
		pub fn cv_gapi_wip_draw_Circle_Circle(ocvrs_return: *mut crate::gapi::Circle);
		pub fn cv_gapi_wip_draw_Image_getPropOrg_const(instance: *const c_void, ocvrs_return: *mut core::Point);
		pub fn cv_gapi_wip_draw_Image_setPropOrg_Point(instance: *mut c_void, val: *const core::Point);
		pub fn cv_gapi_wip_draw_Image_getPropImg_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Image_setPropImg_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_gapi_wip_draw_Image_getPropAlpha_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Image_setPropAlpha_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_gapi_wip_draw_Image_Image_const_PointR_const_MatR_const_MatR(org_: *const core::Point, img_: *const c_void, alpha_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_wip_draw_Image_Image() -> *mut c_void;
		pub fn cv_gapi_wip_draw_Line_Line_const_PointR_const_PointR_const_ScalarR_int_int_int(pt1_: *const core::Point, pt2_: *const core::Point, color_: *const core::Scalar, thick_: i32, lt_: i32, shift_: i32, ocvrs_return: *mut Result<crate::gapi::Line>);
		pub fn cv_gapi_wip_draw_Line_Line(ocvrs_return: *mut crate::gapi::Line);
		pub fn cv_gapi_wip_draw_Mosaic_Mosaic_const_RectR_int_int(mos_: *const core::Rect, cell_sz_: i32, decim_: i32, ocvrs_return: *mut Result<crate::gapi::Mosaic>);
		pub fn cv_gapi_wip_draw_Mosaic_Mosaic(ocvrs_return: *mut Result<crate::gapi::Mosaic>);
		pub fn cv_gapi_wip_draw_Poly_getPropPoints_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Poly_setPropPoints_vectorLPointG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_gapi_wip_draw_Poly_getPropColor_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_gapi_wip_draw_Poly_setPropColor_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_gapi_wip_draw_Poly_getPropThick_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Poly_setPropThick_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Poly_getPropLt_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Poly_setPropLt_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Poly_getPropShift_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Poly_setPropShift_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Poly_Poly_const_vectorLPointGR_const_ScalarR_int_int_int(points_: *const c_void, color_: *const core::Scalar, thick_: i32, lt_: i32, shift_: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_wip_draw_Poly_Poly() -> *mut c_void;
		pub fn cv_gapi_wip_draw_Rect_Rect_const_RectR_const_ScalarR_int_int_int(rect_: *const core::Rect, color_: *const core::Scalar, thick_: i32, lt_: i32, shift_: i32, ocvrs_return: *mut Result<crate::gapi::Rect>);
		pub fn cv_gapi_wip_draw_Rect_Rect(ocvrs_return: *mut crate::gapi::Rect);
		pub fn cv_gapi_wip_draw_Text_getPropText_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Text_setPropText_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_gapi_wip_draw_Text_getPropOrg_const(instance: *const c_void, ocvrs_return: *mut core::Point);
		pub fn cv_gapi_wip_draw_Text_setPropOrg_Point(instance: *mut c_void, val: *const core::Point);
		pub fn cv_gapi_wip_draw_Text_getPropFf_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Text_setPropFf_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Text_getPropFs_const(instance: *const c_void) -> f64;
		pub fn cv_gapi_wip_draw_Text_setPropFs_double(instance: *mut c_void, val: f64);
		pub fn cv_gapi_wip_draw_Text_getPropColor_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_gapi_wip_draw_Text_setPropColor_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_gapi_wip_draw_Text_getPropThick_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Text_setPropThick_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Text_getPropLt_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Text_setPropLt_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Text_getPropBottom_left_origin_const(instance: *const c_void) -> bool;
		pub fn cv_gapi_wip_draw_Text_setPropBottom_left_origin_bool(instance: *mut c_void, val: bool);
		pub fn cv_gapi_wip_draw_Text_Text_const_stringR_const_PointR_int_double_const_ScalarR_int_int_bool(text_: *const c_char, org_: *const core::Point, ff_: i32, fs_: f64, color_: *const core::Scalar, thick_: i32, lt_: i32, bottom_left_origin_: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_wip_draw_Text_Text() -> *mut c_void;
		pub fn cv_util_any_any_const_anyR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_util_any_any_anyR(src: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_util_any_any() -> *mut c_void;
		pub fn cv_util_any_any_anyRR(unnamed: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_gapi)]
pub use gapi_sys::*;

#[cfg(ocvrs_has_module_highgui)]
mod highgui_sys {
	use super::*;

	extern "C" {
		pub fn cv_addText_const_MatR_const_StringR_Point_const_QtFontR(img: *const c_void, text: *const c_char, org: *const core::Point, font: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_addText_const_MatR_const_StringR_Point_const_StringR_int_Scalar_int_int_int(img: *const c_void, text: *const c_char, org: *const core::Point, name_font: *const c_char, point_size: i32, color: *const core::Scalar, weight: i32, style: i32, spacing: i32, ocvrs_return: *mut Result_void);
		pub fn cv_createButton_const_StringR_ButtonCallback_voidX_int_bool(bar_name: *const c_char, on_change: Option<unsafe extern "C" fn(i32, *mut c_void) -> ()>, userdata: *mut c_void, typ: i32, initial_button_state: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_createTrackbar_const_StringR_const_StringR_intX_int_TrackbarCallback_voidX(trackbarname: *const c_char, winname: *const c_char, value: *mut i32, count: i32, on_change: Option<unsafe extern "C" fn(i32, *mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_destroyAllWindows(ocvrs_return: *mut Result_void);
		pub fn cv_destroyWindow_const_StringR(winname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_displayOverlay_const_StringR_const_StringR_int(winname: *const c_char, text: *const c_char, delayms: i32, ocvrs_return: *mut Result_void);
		pub fn cv_displayStatusBar_const_StringR_const_StringR_int(winname: *const c_char, text: *const c_char, delayms: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fontQt_const_StringR_int_Scalar_int_int_int(name_font: *const c_char, point_size: i32, color: *const core::Scalar, weight: i32, style: i32, spacing: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getMouseWheelDelta_int(flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getTrackbarPos_const_StringR_const_StringR(trackbarname: *const c_char, winname: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_getWindowImageRect_const_StringR(winname: *const c_char, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_getWindowProperty_const_StringR_int(winname: *const c_char, prop_id: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_imshow_const_StringR_const__InputArrayR(winname: *const c_char, mat: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_loadWindowParameters_const_StringR(window_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_moveWindow_const_StringR_int_int(winname: *const c_char, x: i32, y: i32, ocvrs_return: *mut Result_void);
		pub fn cv_namedWindow_const_StringR_int(winname: *const c_char, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_pollKey(ocvrs_return: *mut Result<i32>);
		pub fn cv_resizeWindow_const_StringR_const_SizeR(winname: *const c_char, size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_resizeWindow_const_StringR_int_int(winname: *const c_char, width: i32, height: i32, ocvrs_return: *mut Result_void);
		pub fn cv_saveWindowParameters_const_StringR(window_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_selectROI_const_StringR_const__InputArrayR_bool_bool(window_name: *const c_char, img: *const c_void, show_crosshair: bool, from_center: bool, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_selectROI_const__InputArrayR_bool_bool(img: *const c_void, show_crosshair: bool, from_center: bool, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_selectROIs_const_StringR_const__InputArrayR_vectorLRectGR_bool_bool(window_name: *const c_char, img: *const c_void, bounding_boxes: *mut c_void, show_crosshair: bool, from_center: bool, ocvrs_return: *mut Result_void);
		pub fn cv_setMouseCallback_const_StringR_MouseCallback_voidX(winname: *const c_char, on_mouse: Option<unsafe extern "C" fn(i32, i32, i32, i32, *mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_setOpenGlContext_const_StringR(winname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_setOpenGlDrawCallback_const_StringR_OpenGlDrawCallback_voidX(winname: *const c_char, on_opengl_draw: Option<unsafe extern "C" fn(*mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_setTrackbarMax_const_StringR_const_StringR_int(trackbarname: *const c_char, winname: *const c_char, maxval: i32, ocvrs_return: *mut Result_void);
		pub fn cv_setTrackbarMin_const_StringR_const_StringR_int(trackbarname: *const c_char, winname: *const c_char, minval: i32, ocvrs_return: *mut Result_void);
		pub fn cv_setTrackbarPos_const_StringR_const_StringR_int(trackbarname: *const c_char, winname: *const c_char, pos: i32, ocvrs_return: *mut Result_void);
		pub fn cv_setWindowProperty_const_StringR_int_double(winname: *const c_char, prop_id: i32, prop_value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_setWindowTitle_const_StringR_const_StringR(winname: *const c_char, title: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_startLoop_int__X__int__charXX__int_charXX(pt2_func: Option<unsafe extern "C" fn(i32, *mut *mut c_char) -> i32>, argc: i32, argv: *mut *mut c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_startWindowThread(ocvrs_return: *mut Result<i32>);
		pub fn cv_stopLoop(ocvrs_return: *mut Result_void);
		pub fn cv_updateWindow_const_StringR(winname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_waitKeyEx_int(delay: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_waitKey_int(delay: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_QtFont_getPropNameFont_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_QtFont_getPropColor_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_QtFont_setPropColor_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_QtFont_getPropFont_face_const(instance: *const c_void) -> i32;
		pub fn cv_QtFont_setPropFont_face_int(instance: *mut c_void, val: i32);
		pub fn cv_QtFont_getPropAscii_const(instance: *const c_void) -> *const i32;
		pub fn cv_QtFont_getPropGreek_const(instance: *const c_void) -> *const i32;
		pub fn cv_QtFont_getPropCyrillic_const(instance: *const c_void) -> *const i32;
		pub fn cv_QtFont_getPropHscale_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_setPropHscale_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_getPropVscale_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_setPropVscale_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_getPropShear_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_setPropShear_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_getPropThickness_const(instance: *const c_void) -> i32;
		pub fn cv_QtFont_setPropThickness_int(instance: *mut c_void, val: i32);
		pub fn cv_QtFont_getPropDx_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_setPropDx_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_getPropLine_type_const(instance: *const c_void) -> i32;
		pub fn cv_QtFont_setPropLine_type_int(instance: *mut c_void, val: i32);
	}
}
#[cfg(ocvrs_has_module_highgui)]
pub use highgui_sys::*;

#[cfg(ocvrs_has_module_imgcodecs)]
mod imgcodecs_sys {
	use super::*;

	extern "C" {
		pub fn cv_haveImageReader_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_haveImageWriter_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_imcount_const_StringR_int(filename: *const c_char, flags: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_imdecode_const__InputArrayR_int(buf: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imdecode_const__InputArrayR_int_MatX(buf: *const c_void, flags: i32, dst: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imencode_const_StringR_const__InputArrayR_vectorLunsigned_charGR_const_vectorLintGR(ext: *const c_char, img: *const c_void, buf: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imread_const_StringR_int(filename: *const c_char, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imreadmulti_const_StringR_vectorLMatGR_int(filename: *const c_char, mats: *mut c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_imreadmulti_const_StringR_vectorLMatGR_int_int_int(filename: *const c_char, mats: *mut c_void, start: i32, count: i32, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwrite_const_StringR_const__InputArrayR_const_vectorLintGR(filename: *const c_char, img: *const c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwritemulti_const_StringR_const__InputArrayR_const_vectorLintGR(filename: *const c_char, img: *const c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
	}
}
#[cfg(ocvrs_has_module_imgcodecs)]
pub use imgcodecs_sys::*;

#[cfg(ocvrs_has_module_imgproc)]
mod imgproc_sys {
	use super::*;

	extern "C" {
		pub fn cv_Canny_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double_bool(dx: *const c_void, dy: *const c_void, edges: *const c_void, threshold1: f64, threshold2: f64, l2gradient: bool, ocvrs_return: *mut Result_void);
		pub fn cv_Canny_const__InputArrayR_const__OutputArrayR_double_double_int_bool(image: *const c_void, edges: *const c_void, threshold1: f64, threshold2: f64, aperture_size: i32, l2gradient: bool, ocvrs_return: *mut Result_void);
		pub fn cv_EMD_const__InputArrayR_const__InputArrayR_int_const__InputArrayR_floatX_const__OutputArrayR(signature1: *const c_void, signature2: *const c_void, dist_type: i32, cost: *const c_void, lower_bound: *mut f32, flow: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_GaussianBlur_const__InputArrayR_const__OutputArrayR_Size_double_double_int(src: *const c_void, dst: *const c_void, ksize: *const core::Size, sigma_x: f64, sigma_y: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_HoughCircles_const__InputArrayR_const__OutputArrayR_int_double_double_double_double_int_int(image: *const c_void, circles: *const c_void, method: i32, dp: f64, min_dist: f64, param1: f64, param2: f64, min_radius: i32, max_radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_HoughLinesP_const__InputArrayR_const__OutputArrayR_double_double_int_double_double(image: *const c_void, lines: *const c_void, rho: f64, theta: f64, threshold: i32, min_line_length: f64, max_line_gap: f64, ocvrs_return: *mut Result_void);
		pub fn cv_HoughLinesPointSet_const__InputArrayR_const__OutputArrayR_int_int_double_double_double_double_double_double(point: *const c_void, lines: *const c_void, lines_max: i32, threshold: i32, min_rho: f64, max_rho: f64, rho_step: f64, min_theta: f64, max_theta: f64, theta_step: f64, ocvrs_return: *mut Result_void);
		pub fn cv_HoughLines_const__InputArrayR_const__OutputArrayR_double_double_int_double_double_double_double(image: *const c_void, lines: *const c_void, rho: f64, theta: f64, threshold: i32, srn: f64, stn: f64, min_theta: f64, max_theta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_HuMoments_const_MomentsR_const__OutputArrayR(m: *const core::Moments, hu: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HuMoments_const_MomentsR_doubleXX(moments: *const core::Moments, hu: *mut [f64; 7], ocvrs_return: *mut Result_void);
		pub fn cv_Laplacian_const__InputArrayR_const__OutputArrayR_int_int_double_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Scharr_const__InputArrayR_const__OutputArrayR_int_int_int_double_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, dx: i32, dy: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Sobel_const__InputArrayR_const__OutputArrayR_int_int_int_int_double_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, dx: i32, dy: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_accumulateProduct_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_accumulateSquare_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_accumulateWeighted_const__InputArrayR_const__InputOutputArrayR_double_const__InputArrayR(src: *const c_void, dst: *const c_void, alpha: f64, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_accumulate_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_adaptiveThreshold_const__InputArrayR_const__OutputArrayR_double_int_int_int_double(src: *const c_void, dst: *const c_void, max_value: f64, adaptive_method: i32, threshold_type: i32, block_size: i32, c: f64, ocvrs_return: *mut Result_void);
		pub fn cv_applyColorMap_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, user_color: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_applyColorMap_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, colormap: i32, ocvrs_return: *mut Result_void);
		pub fn cv_approxPolyDP_const__InputArrayR_const__OutputArrayR_double_bool(curve: *const c_void, approx_curve: *const c_void, epsilon: f64, closed: bool, ocvrs_return: *mut Result_void);
		pub fn cv_arcLength_const__InputArrayR_bool(curve: *const c_void, closed: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_arrowedLine_const__InputOutputArrayR_Point_Point_const_ScalarR_int_int_int_double(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, tip_length: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bilateralFilter_const__InputArrayR_const__OutputArrayR_int_double_double_int(src: *const c_void, dst: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_blendLinear_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, weights1: *const c_void, weights2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_blur_const__InputArrayR_const__OutputArrayR_Size_Point_int(src: *const c_void, dst: *const c_void, ksize: *const core::Size, anchor: *const core::Point, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_boundingRect_const__InputArrayR(array: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_boxFilter_const__InputArrayR_const__OutputArrayR_int_Size_Point_bool_int(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: *const core::Size, anchor: *const core::Point, normalize: bool, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_boxPoints_RotatedRect_const__OutputArrayR(box_: *mut c_void, points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_buildPyramid_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, maxlevel: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_calcBackProject_const__InputArrayR_const_vectorLintGR_const__InputArrayR_const__OutputArrayR_const_vectorLfloatGR_double(images: *const c_void, channels: *const c_void, hist: *const c_void, dst: *const c_void, ranges: *const c_void, scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_calcHist_const__InputArrayR_const_vectorLintGR_const__InputArrayR_const__OutputArrayR_const_vectorLintGR_const_vectorLfloatGR_bool(images: *const c_void, channels: *const c_void, mask: *const c_void, hist: *const c_void, hist_size: *const c_void, ranges: *const c_void, accumulate: bool, ocvrs_return: *mut Result_void);
		pub fn cv_circle_const__InputOutputArrayR_Point_int_const_ScalarR_int_int_int(img: *const c_void, center: *const core::Point, radius: i32, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_clipLine_Rect_PointR_PointR(img_rect: *const core::Rect, pt1: *mut core::Point, pt2: *mut core::Point, ocvrs_return: *mut Result<bool>);
		pub fn cv_clipLine_Size2l_Point2lR_Point2lR(img_size: *const core::Size2l, pt1: *mut core::Point2l, pt2: *mut core::Point2l, ocvrs_return: *mut Result<bool>);
		pub fn cv_clipLine_Size_PointR_PointR(img_size: *const core::Size, pt1: *mut core::Point, pt2: *mut core::Point, ocvrs_return: *mut Result<bool>);
		pub fn cv_compareHist_const_SparseMatR_const_SparseMatR_int(h1: *const c_void, h2: *const c_void, method: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_compareHist_const__InputArrayR_const__InputArrayR_int(h1: *const c_void, h2: *const c_void, method: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_connectedComponentsWithStats_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(image: *const c_void, labels: *const c_void, stats: *const c_void, centroids: *const c_void, connectivity: i32, ltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponentsWithStats_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_int_int(image: *const c_void, labels: *const c_void, stats: *const c_void, centroids: *const c_void, connectivity: i32, ltype: i32, ccltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponents_const__InputArrayR_const__OutputArrayR_int_int(image: *const c_void, labels: *const c_void, connectivity: i32, ltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponents_const__InputArrayR_const__OutputArrayR_int_int_int(image: *const c_void, labels: *const c_void, connectivity: i32, ltype: i32, ccltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_contourArea_const__InputArrayR_bool(contour: *const c_void, oriented: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_convertMaps_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_bool(map1: *const c_void, map2: *const c_void, dstmap1: *const c_void, dstmap2: *const c_void, dstmap1type: i32, nninterpolation: bool, ocvrs_return: *mut Result_void);
		pub fn cv_convexHull_const__InputArrayR_const__OutputArrayR_bool_bool(points: *const c_void, hull: *const c_void, clockwise: bool, return_points: bool, ocvrs_return: *mut Result_void);
		pub fn cv_convexityDefects_const__InputArrayR_const__InputArrayR_const__OutputArrayR(contour: *const c_void, convexhull: *const c_void, convexity_defects: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cornerEigenValsAndVecs_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cornerHarris_const__InputArrayR_const__OutputArrayR_int_int_double_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, k: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cornerMinEigenVal_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cornerSubPix_const__InputArrayR_const__InputOutputArrayR_Size_Size_TermCriteria(image: *const c_void, corners: *const c_void, win_size: *const core::Size, zero_zone: *const core::Size, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_createCLAHE_double_Size(clip_limit: f64, tile_grid_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createGeneralizedHoughBallard(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createGeneralizedHoughGuil(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createHanningWindow_const__OutputArrayR_Size_int(dst: *const c_void, win_size: *const core::Size, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_createLineSegmentDetector_int_double_double_double_double_double_double_int(refine: i32, scale: f64, sigma_scale: f64, quant: f64, ang_th: f64, log_eps: f64, density_th: f64, n_bins: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cvtColorTwoPlane_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cvtColor_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, code: i32, dst_cn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_demosaicing_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, code: i32, dst_cn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dilate_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Point_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_distanceTransform_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, labels: *const c_void, distance_type: i32, mask_size: i32, label_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_distanceTransform_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, distance_type: i32, mask_size: i32, dst_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_divSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_bool(a: *const c_void, b: *const c_void, c: *const c_void, flags: i32, conj_b: bool, ocvrs_return: *mut Result_void);
		pub fn cv_drawContours_const__InputOutputArrayR_const__InputArrayR_int_const_ScalarR_int_int_const__InputArrayR_int_Point(image: *const c_void, contours: *const c_void, contour_idx: i32, color: *const core::Scalar, thickness: i32, line_type: i32, hierarchy: *const c_void, max_level: i32, offset: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_drawMarker_const__InputOutputArrayR_Point_const_ScalarR_int_int_int_int(img: *const c_void, position: *const core::Point, color: *const core::Scalar, marker_type: i32, marker_size: i32, thickness: i32, line_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ellipse2Poly_Point2d_Size2d_int_int_int_int_vectorLPoint2dGR(center: *const core::Point2d, axes: *const core::Size2d, angle: i32, arc_start: i32, arc_end: i32, delta: i32, pts: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ellipse2Poly_Point_Size_int_int_int_int_vectorLPointGR(center: *const core::Point, axes: *const core::Size, angle: i32, arc_start: i32, arc_end: i32, delta: i32, pts: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ellipse_const__InputOutputArrayR_Point_Size_double_double_double_const_ScalarR_int_int_int(img: *const c_void, center: *const core::Point, axes: *const core::Size, angle: f64, start_angle: f64, end_angle: f64, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ellipse_const__InputOutputArrayR_const_RotatedRectR_const_ScalarR_int_int(img: *const c_void, box_: *const c_void, color: *const core::Scalar, thickness: i32, line_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_equalizeHist_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_erode_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Point_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_fillConvexPoly_const__InputOutputArrayR_const__InputArrayR_const_ScalarR_int_int(img: *const c_void, points: *const c_void, color: *const core::Scalar, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fillPoly_const__InputOutputArrayR_const__InputArrayR_const_ScalarR_int_int_Point(img: *const c_void, pts: *const c_void, color: *const core::Scalar, line_type: i32, shift: i32, offset: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_filter2D_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_Point_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, kernel: *const c_void, anchor: *const core::Point, delta: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_findContours_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int_Point(image: *const c_void, contours: *const c_void, hierarchy: *const c_void, mode: i32, method: i32, offset: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_findContours_const__InputArrayR_const__OutputArrayR_int_int_Point(image: *const c_void, contours: *const c_void, mode: i32, method: i32, offset: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_fitEllipseAMS_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_fitEllipseDirect_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_fitEllipse_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_fitLine_const__InputArrayR_const__OutputArrayR_int_double_double_double(points: *const c_void, line: *const c_void, dist_type: i32, param: f64, reps: f64, aeps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_floodFill_const__InputOutputArrayR_Point_Scalar_RectX_Scalar_Scalar_int(image: *const c_void, seed_point: *const core::Point, new_val: *const core::Scalar, rect: *mut core::Rect, lo_diff: *const core::Scalar, up_diff: *const core::Scalar, flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_floodFill_const__InputOutputArrayR_const__InputOutputArrayR_Point_Scalar_RectX_Scalar_Scalar_int(image: *const c_void, mask: *const c_void, seed_point: *const core::Point, new_val: *const core::Scalar, rect: *mut core::Rect, lo_diff: *const core::Scalar, up_diff: *const core::Scalar, flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getAffineTransform_const_Point2fX_const_Point2fX(src: *const core::Point2f, dst: *const core::Point2f, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getAffineTransform_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getDerivKernels_const__OutputArrayR_const__OutputArrayR_int_int_int_bool_int(kx: *const c_void, ky: *const c_void, dx: i32, dy: i32, ksize: i32, normalize: bool, ktype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_getFontScaleFromHeight_const_int_const_int_const_int(font_face: i32, pixel_height: i32, thickness: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_getGaborKernel_Size_double_double_double_double_double_int(ksize: *const core::Size, sigma: f64, theta: f64, lambd: f64, gamma: f64, psi: f64, ktype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getGaussianKernel_int_double_int(ksize: i32, sigma: f64, ktype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getPerspectiveTransform_const_Point2fX_const_Point2fX_int(src: *const core::Point2f, dst: *const core::Point2f, solve_method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getPerspectiveTransform_const__InputArrayR_const__InputArrayR_int(src: *const c_void, dst: *const c_void, solve_method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getRectSubPix_const__InputArrayR_Size_Point2f_const__OutputArrayR_int(image: *const c_void, patch_size: *const core::Size, center: *const core::Point2f, patch: *const c_void, patch_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_getRotationMatrix2D_Point2f_double_double(center: *const core::Point2f, angle: f64, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		#[cfg(not(target_os = "windows"))]
		pub fn cv_getRotationMatrix2D__Point2f_double_double(center: *const core::Point2f, angle: f64, scale: f64, ocvrs_return: *mut Result<core::Matx23d>);
		pub fn cv_getStructuringElement_int_Size_Point(shape: i32, ksize: *const core::Size, anchor: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getTextSize_const_StringR_int_double_int_intX(text: *const c_char, font_face: i32, font_scale: f64, thickness: i32, base_line: *mut i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_const__OutputArrayR_int_int_bool_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, corners_quality: *const c_void, block_size: i32, gradient_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result_void);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_int_bool_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, block_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result_void);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_int_int_bool_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, block_size: i32, gradient_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result_void);
		pub fn cv_grabCut_const__InputArrayR_const__InputOutputArrayR_Rect_const__InputOutputArrayR_const__InputOutputArrayR_int_int(img: *const c_void, mask: *const c_void, rect: *const core::Rect, bgd_model: *const c_void, fgd_model: *const c_void, iter_count: i32, mode: i32, ocvrs_return: *mut Result_void);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, sum: *const c_void, sqsum: *const c_void, tilted: *const c_void, sdepth: i32, sqdepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, sum: *const c_void, sqsum: *const c_void, sdepth: i32, sqdepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, sum: *const c_void, sdepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_intersectConvexConvex_const__InputArrayR_const__InputArrayR_const__OutputArrayR_bool(p1: *const c_void, p2: *const c_void, p12: *const c_void, handle_nested: bool, ocvrs_return: *mut Result<f32>);
		pub fn cv_invertAffineTransform_const__InputArrayR_const__OutputArrayR(m: *const c_void, i_m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_isContourConvex_const__InputArrayR(contour: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_line_const__InputOutputArrayR_Point_Point_const_ScalarR_int_int_int(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_linearPolar_const__InputArrayR_const__OutputArrayR_Point2f_double_int(src: *const c_void, dst: *const c_void, center: *const core::Point2f, max_radius: f64, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_logPolar_const__InputArrayR_const__OutputArrayR_Point2f_double_int(src: *const c_void, dst: *const c_void, center: *const core::Point2f, m: f64, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_matchShapes_const__InputArrayR_const__InputArrayR_int_double(contour1: *const c_void, contour2: *const c_void, method: i32, parameter: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_matchTemplate_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR(image: *const c_void, templ: *const c_void, result: *const c_void, method: i32, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_medianBlur_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, ksize: i32, ocvrs_return: *mut Result_void);
		pub fn cv_minAreaRect_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_minEnclosingCircle_const__InputArrayR_Point2fR_floatR(points: *const c_void, center: *mut core::Point2f, radius: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_minEnclosingTriangle_const__InputArrayR_const__OutputArrayR(points: *const c_void, triangle: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_moments_const__InputArrayR_bool(array: *const c_void, binary_image: bool, ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_morphologyDefaultBorderValue(ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_morphologyEx_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_Point_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, op: i32, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_phaseCorrelate_const__InputArrayR_const__InputArrayR_const__InputArrayR_doubleX(src1: *const c_void, src2: *const c_void, window: *const c_void, response: *mut f64, ocvrs_return: *mut Result<core::Point2d>);
		pub fn cv_pointPolygonTest_const__InputArrayR_Point2f_bool(contour: *const c_void, pt: *const core::Point2f, measure_dist: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_polylines_const__InputOutputArrayR_const__InputArrayR_bool_const_ScalarR_int_int_int(img: *const c_void, pts: *const c_void, is_closed: bool, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_preCornerDetect_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, ksize: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_putText_const__InputOutputArrayR_const_StringR_Point_int_double_Scalar_int_int_bool(img: *const c_void, text: *const c_char, org: *const core::Point, font_face: i32, font_scale: f64, color: *const core::Scalar, thickness: i32, line_type: i32, bottom_left_origin: bool, ocvrs_return: *mut Result_void);
		pub fn cv_pyrDown_const__InputArrayR_const__OutputArrayR_const_SizeR_int(src: *const c_void, dst: *const c_void, dstsize: *const core::Size, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_pyrMeanShiftFiltering_const__InputArrayR_const__OutputArrayR_double_double_int_TermCriteria(src: *const c_void, dst: *const c_void, sp: f64, sr: f64, max_level: i32, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_pyrUp_const__InputArrayR_const__OutputArrayR_const_SizeR_int(src: *const c_void, dst: *const c_void, dstsize: *const core::Size, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rectangle_const__InputOutputArrayR_Point_Point_const_ScalarR_int_int_int(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rectangle_const__InputOutputArrayR_Rect_const_ScalarR_int_int_int(img: *const c_void, rec: *const core::Rect, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_remap_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, map1: *const c_void, map2: *const c_void, interpolation: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_resize_const__InputArrayR_const__OutputArrayR_Size_double_double_int(src: *const c_void, dst: *const c_void, dsize: *const core::Size, fx: f64, fy: f64, interpolation: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rotatedRectangleIntersection_const_RotatedRectR_const_RotatedRectR_const__OutputArrayR(rect1: *const c_void, rect2: *const c_void, intersecting_region: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_sepFilter2D_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_const__InputArrayR_Point_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, kernel_x: *const c_void, kernel_y: *const c_void, anchor: *const core::Point, delta: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_spatialGradient_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, dx: *const c_void, dy: *const c_void, ksize: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_sqrBoxFilter_const__InputArrayR_const__OutputArrayR_int_Size_Point_bool_int(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: *const core::Size, anchor: *const core::Point, normalize: bool, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_threshold_const__InputArrayR_const__OutputArrayR_double_double_int(src: *const c_void, dst: *const c_void, thresh: f64, maxval: f64, typ: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_warpAffine_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_warpPerspective_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_warpPolar_const__InputArrayR_const__OutputArrayR_Size_Point2f_double_int(src: *const c_void, dst: *const c_void, dsize: *const core::Size, center: *const core::Point2f, max_radius: f64, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_watershed_const__InputArrayR_const__InputOutputArrayR(image: *const c_void, markers: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_wrapperEMD_const__InputArrayR_const__InputArrayR_int_const__InputArrayR_PtrLfloatG_const__OutputArrayR(signature1: *const c_void, signature2: *const c_void, dist_type: i32, cost: *const c_void, lower_bound: *mut c_void, flow: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_CLAHE_apply_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CLAHE_setClipLimit_double(instance: *mut c_void, clip_limit: f64, ocvrs_return: *mut Result_void);
		pub fn cv_CLAHE_getClipLimit_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_CLAHE_setTilesGridSize_Size(instance: *mut c_void, tile_grid_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_CLAHE_getTilesGridSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_CLAHE_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayR_Point(instance: *mut c_void, templ: *const c_void, templ_center: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayR_const__InputArrayR_const__InputArrayR_Point(instance: *mut c_void, edges: *const c_void, dx: *const c_void, dy: *const c_void, templ_center: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_detect_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, positions: *const c_void, votes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_detect_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, edges: *const c_void, dx: *const c_void, dy: *const c_void, positions: *const c_void, votes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_setCannyLowThresh_int(instance: *mut c_void, canny_low_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_getCannyLowThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHough_setCannyHighThresh_int(instance: *mut c_void, canny_high_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_getCannyHighThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHough_setMinDist_double(instance: *mut c_void, min_dist: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_getMinDist_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHough_setDp_double(instance: *mut c_void, dp: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_getDp_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHough_setMaxBufferSize_int(instance: *mut c_void, max_buffer_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_getMaxBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughBallard_setLevels_int(instance: *mut c_void, levels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughBallard_getLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughBallard_setVotesThreshold_int(instance: *mut c_void, votes_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughBallard_getVotesThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_setXi_double(instance: *mut c_void, xi: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getXi_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setLevels_int(instance: *mut c_void, levels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_setAngleEpsilon_double(instance: *mut c_void, angle_epsilon: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getAngleEpsilon_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setMinAngle_double(instance: *mut c_void, min_angle: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getMinAngle_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setMaxAngle_double(instance: *mut c_void, max_angle: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getMaxAngle_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setAngleStep_double(instance: *mut c_void, angle_step: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getAngleStep_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setAngleThresh_int(instance: *mut c_void, angle_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getAngleThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_setMinScale_double(instance: *mut c_void, min_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getMinScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setMaxScale_double(instance: *mut c_void, max_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getMaxScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setScaleStep_double(instance: *mut c_void, scale_step: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getScaleStep_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setScaleThresh_int(instance: *mut c_void, scale_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getScaleThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_setPosThresh_int(instance: *mut c_void, pos_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getPosThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_LineIterator_getPropPtr(instance: *mut c_void) -> *mut u8;
		pub fn cv_LineIterator_setPropPtr_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_LineIterator_getPropPtr0_const(instance: *const c_void) -> *const u8;
		pub fn cv_LineIterator_getPropStep_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_setPropStep_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_getPropElemSize_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_setPropElemSize_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_getPropErr_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_setPropErr_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_getPropCount_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_setPropCount_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_getPropMinusDelta_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_setPropMinusDelta_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_getPropPlusDelta_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_setPropPlusDelta_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_getPropMinusStep_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_setPropMinusStep_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_getPropPlusStep_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_setPropPlusStep_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_getPropMinusShift_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_setPropMinusShift_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_getPropPlusShift_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_setPropPlusShift_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_getPropP_const(instance: *const c_void, ocvrs_return: *mut core::Point);
		pub fn cv_LineIterator_setPropP_Point(instance: *mut c_void, val: *const core::Point);
		pub fn cv_LineIterator_getPropPtmode_const(instance: *const c_void) -> bool;
		pub fn cv_LineIterator_setPropPtmode_bool(instance: *mut c_void, val: bool);
		pub fn cv_LineIterator_LineIterator_const_MatR_Point_Point_int_bool(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Point_Point_int_bool(pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Size_Point_Point_int_bool(bounding_area_size: *const core::Size, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Rect_Point_Point_int_bool(bounding_area_rect: *const core::Rect, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_init_const_MatX_Rect_Point_Point_int_bool(instance: *mut c_void, img: *const c_void, bounding_area_rect: *const core::Rect, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result_void);
		pub fn cv_LineIterator_operatorX(instance: *mut c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_LineIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_pos_const(instance: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_LineSegmentDetector_detect_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, lines: *const c_void, width: *const c_void, prec: *const c_void, nfa: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LineSegmentDetector_drawSegments_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, image: *const c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LineSegmentDetector_compareSegments_const_SizeR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(instance: *mut c_void, size: *const core::Size, lines1: *const c_void, lines2: *const c_void, image: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_Subdiv2D(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Subdiv2D_Subdiv2D_Rect(rect: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Subdiv2D_initDelaunay_Rect(instance: *mut c_void, rect: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_insert_Point2f(instance: *mut c_void, pt: *const core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_insert_const_vectorLPoint2fGR(instance: *mut c_void, ptvec: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_locate_Point2f_intR_intR(instance: *mut c_void, pt: *const core::Point2f, edge: *mut i32, vertex: *mut i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_findNearest_Point2f_Point2fX(instance: *mut c_void, pt: *const core::Point2f, nearest_pt: *mut core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_getEdgeList_const_vectorLVec4fGR(instance: *const c_void, edge_list: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_getLeadingEdgeList_const_vectorLintGR(instance: *const c_void, leading_edge_list: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_getTriangleList_const_vectorLVec6fGR(instance: *const c_void, triangle_list: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_getVoronoiFacetList_const_vectorLintGR_vectorLvectorLPoint2fGGR_vectorLPoint2fGR(instance: *mut c_void, idx: *const c_void, facet_list: *mut c_void, facet_centers: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_getVertex_const_int_intX(instance: *const c_void, vertex: i32, first_edge: *mut i32, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_Subdiv2D_getEdge_const_int_int(instance: *const c_void, edge: i32, next_edge_type: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_nextEdge_const_int(instance: *const c_void, edge: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_rotateEdge_const_int_int(instance: *const c_void, edge: i32, rotate: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_symEdge_const_int(instance: *const c_void, edge: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_edgeOrg_const_int_Point2fX(instance: *const c_void, edge: i32, orgpt: *mut core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_edgeDst_const_int_Point2fX(instance: *const c_void, edge: i32, dstpt: *mut core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_segmentation_IntelligentScissorsMB_IntelligentScissorsMB(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setWeights_float_float_float(instance: *mut c_void, weight_non_edge: f32, weight_gradient_direction: f32, weight_gradient_magnitude: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setGradientMagnitudeMaxLimit_float(instance: *mut c_void, gradient_magnitude_threshold_max: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setEdgeFeatureZeroCrossingParameters_float(instance: *mut c_void, gradient_magnitude_min_value: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setEdgeFeatureCannyParameters_double_double_int_bool(instance: *mut c_void, threshold1: f64, threshold2: f64, aperture_size: i32, l2gradient: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_applyImage_const__InputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_applyImageFeatures_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, non_edge: *const c_void, gradient_direction: *const c_void, gradient_magnitude: *const c_void, image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_buildMap_const_PointR(instance: *mut c_void, source_pt: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_segmentation_IntelligentScissorsMB_getContour_const_const_PointR_const__OutputArrayR_bool(instance: *const c_void, target_pt: *const core::Point, contour: *const c_void, backward: bool, ocvrs_return: *mut Result_void);
	}
}
#[cfg(ocvrs_has_module_imgproc)]
pub use imgproc_sys::*;

#[cfg(ocvrs_has_module_ml)]
mod ml_sys {
	use super::*;

	extern "C" {
		pub fn cv_ml_createConcentricSpheresTestSet_int_int_int_const__OutputArrayR_const__OutputArrayR(nsamples: i32, nfeatures: i32, nclasses: i32, samples: *const c_void, responses: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_randMVNormal_const__InputArrayR_const__InputArrayR_int_const__OutputArrayR(mean: *const c_void, cov: *const c_void, nsamples: i32, samples: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_setTrainMethod_int_double_double(instance: *mut c_void, method: i32, param1: f64, param2: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getTrainMethod_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_ANN_MLP_setActivationFunction_int_double_double(instance: *mut c_void, typ: i32, param1: f64, param2: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_setLayerSizes_const__InputArrayR(instance: *mut c_void, _layer_sizes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getLayerSizes_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ANN_MLP_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_ANN_MLP_setTermCriteria_TermCriteria(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getBackpropWeightScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setBackpropWeightScale_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getBackpropMomentumScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setBackpropMomentumScale_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getRpropDW0_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setRpropDW0_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getRpropDWPlus_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setRpropDWPlus_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getRpropDWMinus_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setRpropDWMinus_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getRpropDWMin_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setRpropDWMin_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getRpropDWMax_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setRpropDWMax_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getAnnealInitialT_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setAnnealInitialT_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getAnnealFinalT_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setAnnealFinalT_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getAnnealCoolingRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setAnnealCoolingRatio_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getAnnealItePerStep_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_ANN_MLP_setAnnealItePerStep_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_setAnnealEnergyRNG_const_RNGR(instance: *mut c_void, rng: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getWeights_const_int(instance: *const c_void, layer_idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ANN_MLP_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ANN_MLP_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_Boost_getBoostType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_Boost_setBoostType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_Boost_getWeakCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_Boost_setWeakCount_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_Boost_getWeightTrimRate_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_Boost_setWeightTrimRate_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_Boost_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_Boost_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_getMaxCategories_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_DTrees_setMaxCategories_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getMaxDepth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_DTrees_setMaxDepth_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getMinSampleCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_DTrees_setMinSampleCount_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getCVFolds_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_DTrees_setCVFolds_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getUseSurrogates_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_DTrees_setUseSurrogates_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getUse1SERule_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_DTrees_setUse1SERule_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getTruncatePrunedTree_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_DTrees_setTruncatePrunedTree_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getRegressionAccuracy_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_DTrees_setRegressionAccuracy_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getPriors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_setPriors_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getRoots_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_getNodes_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_getSplits_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_getSubsets_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_Node_getPropValue_const(instance: *const c_void) -> f64;
		pub fn cv_ml_DTrees_Node_setPropValue_double(instance: *mut c_void, val: f64);
		pub fn cv_ml_DTrees_Node_getPropClassIdx_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_setPropClassIdx_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_getPropParent_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_setPropParent_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_getPropLeft_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_setPropLeft_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_getPropRight_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_setPropRight_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_getPropDefaultDir_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_setPropDefaultDir_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_getPropSplit_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_setPropSplit_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_Node(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_Split_getPropVarIdx_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Split_setPropVarIdx_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Split_getPropInversed_const(instance: *const c_void) -> bool;
		pub fn cv_ml_DTrees_Split_setPropInversed_bool(instance: *mut c_void, val: bool);
		pub fn cv_ml_DTrees_Split_getPropQuality_const(instance: *const c_void) -> f32;
		pub fn cv_ml_DTrees_Split_setPropQuality_float(instance: *mut c_void, val: f32);
		pub fn cv_ml_DTrees_Split_getPropNext_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Split_setPropNext_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Split_getPropC_const(instance: *const c_void) -> f32;
		pub fn cv_ml_DTrees_Split_setPropC_float(instance: *mut c_void, val: f32);
		pub fn cv_ml_DTrees_Split_getPropSubsetOfs_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Split_setPropSubsetOfs_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Split_Split(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_EM_getClustersNumber_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_EM_setClustersNumber_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_EM_getCovarianceMatrixType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_EM_setCovarianceMatrixType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_EM_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_EM_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_EM_getWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_EM_getMeans_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_EM_getCovs_const_vectorLMatGR(instance: *const c_void, covs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_EM_predict_const_const__InputArrayR_const__OutputArrayR_int(instance: *const c_void, samples: *const c_void, results: *const c_void, flags: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_EM_predict2_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, sample: *const c_void, probs: *const c_void, ocvrs_return: *mut Result<core::Vec2d>);
		pub fn cv_ml_EM_trainEM_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, samples: *const c_void, log_likelihoods: *const c_void, labels: *const c_void, probs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_EM_trainE_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, samples: *const c_void, means0: *const c_void, covs0: *const c_void, weights0: *const c_void, log_likelihoods: *const c_void, labels: *const c_void, probs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_EM_trainM_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, samples: *const c_void, probs0: *const c_void, log_likelihoods: *const c_void, labels: *const c_void, probs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_EM_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_EM_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_KNearest_getDefaultK_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_KNearest_setDefaultK_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_KNearest_getIsClassifier_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_KNearest_setIsClassifier_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_KNearest_getEmax_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_KNearest_setEmax_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_KNearest_getAlgorithmType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_KNearest_setAlgorithmType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_KNearest_findNearest_const_const__InputArrayR_int_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, samples: *const c_void, k: i32, results: *const c_void, neighbor_responses: *const c_void, dist: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_KNearest_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_KNearest_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_LogisticRegression_getLearningRate_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_LogisticRegression_setLearningRate_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_getIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_LogisticRegression_setIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_getRegularization_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_LogisticRegression_setRegularization_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_getTrainMethod_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_LogisticRegression_setTrainMethod_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_getMiniBatchSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_LogisticRegression_setMiniBatchSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_LogisticRegression_setTermCriteria_TermCriteria(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_predict_const_const__InputArrayR_const__OutputArrayR_int(instance: *const c_void, samples: *const c_void, results: *const c_void, flags: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_LogisticRegression_get_learnt_thetas_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_LogisticRegression_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_LogisticRegression_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_NormalBayesClassifier_predictProb_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int(instance: *const c_void, inputs: *const c_void, outputs: *const c_void, output_probs: *const c_void, flags: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_NormalBayesClassifier_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_NormalBayesClassifier_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ParamGrid_getPropMinVal_const(instance: *const c_void) -> f64;
		pub fn cv_ml_ParamGrid_setPropMinVal_double(instance: *mut c_void, val: f64);
		pub fn cv_ml_ParamGrid_getPropMaxVal_const(instance: *const c_void) -> f64;
		pub fn cv_ml_ParamGrid_setPropMaxVal_double(instance: *mut c_void, val: f64);
		pub fn cv_ml_ParamGrid_getPropLogStep_const(instance: *const c_void) -> f64;
		pub fn cv_ml_ParamGrid_setPropLogStep_double(instance: *mut c_void, val: f64);
		pub fn cv_ml_ParamGrid_ParamGrid(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ParamGrid_ParamGrid_double_double_double(_min_val: f64, _max_val: f64, _log_step: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ParamGrid_create_double_double_double(min_val: f64, max_val: f64, logstep: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_RTrees_getCalculateVarImportance_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_RTrees_setCalculateVarImportance_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_RTrees_getActiveVarCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_RTrees_setActiveVarCount_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_RTrees_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_RTrees_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_RTrees_getVarImportance_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_RTrees_getVotes_const_const__InputArrayR_const__OutputArrayR_int(instance: *const c_void, samples: *const c_void, results: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_RTrees_getOOBError_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_RTrees_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_RTrees_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_getType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_SVM_setType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setGamma_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getCoef0_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setCoef0_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getDegree_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setDegree_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getC_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setC_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getNu_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setNu_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getP_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setP_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getClassWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_setClassWeights_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_SVM_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getKernelType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_SVM_setKernel_int(instance: *mut c_void, kernel_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_setCustomKernel_const_PtrLKernelGR(instance: *mut c_void, _kernel: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_trainAuto_const_PtrLTrainDataGR_int_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_bool(instance: *mut c_void, data: *const c_void, k_fold: i32, cgrid: *mut c_void, gamma_grid: *mut c_void, p_grid: *mut c_void, nu_grid: *mut c_void, coeff_grid: *mut c_void, degree_grid: *mut c_void, balanced: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_SVM_trainAuto_const__InputArrayR_int_const__InputArrayR_int_PtrLParamGridG_PtrLParamGridG_PtrLParamGridG_PtrLParamGridG_PtrLParamGridG_PtrLParamGridG_bool(instance: *mut c_void, samples: *const c_void, layout: i32, responses: *const c_void, k_fold: i32, cgrid: *mut c_void, gamma_grid: *mut c_void, p_grid: *mut c_void, nu_grid: *mut c_void, coeff_grid: *mut c_void, degree_grid: *mut c_void, balanced: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_SVM_getSupportVectors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_getUncompressedSupportVectors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_getDecisionFunction_const_int_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, i: i32, alpha: *const c_void, svidx: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_getDefaultGrid_int(param_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_getDefaultGridPtr_int(param_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_Kernel_getType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_SVM_Kernel_calc_int_int_const_floatX_const_floatX_floatX(instance: *mut c_void, vcount: i32, n: i32, vecs: *const f32, another: *const f32, results: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getWeights(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVMSGD_getShift(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_SVMSGD_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVMSGD_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVMSGD_setOptimalParameters_int_int(instance: *mut c_void, svmsgd_type: i32, margin_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getSvmsgdType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_SVMSGD_setSvmsgdType_int(instance: *mut c_void, svmsgd_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getMarginType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_SVMSGD_setMarginType_int(instance: *mut c_void, margin_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getMarginRegularization_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_SVMSGD_setMarginRegularization_float(instance: *mut c_void, margin_regularization: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getInitialStepSize_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_SVMSGD_setInitialStepSize_float(instance: *mut c_void, initial_step_size: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getStepDecreasingPower_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_SVMSGD_setStepDecreasingPower_float(instance: *mut c_void, step_decreasing_power: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_SVMSGD_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_StatModel_getVarCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_StatModel_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_isTrained_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_isClassifier_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_train_const_PtrLTrainDataGR_int(instance: *mut c_void, train_data: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_train_const__InputArrayR_int_const__InputArrayR(instance: *mut c_void, samples: *const c_void, layout: i32, responses: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_calcError_const_const_PtrLTrainDataGR_bool_const__OutputArrayR(instance: *const c_void, data: *const c_void, test: bool, resp: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_StatModel_predict_const_const__InputArrayR_const__OutputArrayR_int(instance: *const c_void, samples: *const c_void, results: *const c_void, flags: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_TrainData_missingValue(ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_TrainData_getLayout_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getNTrainSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getNTestSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getNSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getNVars_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getNAllVars_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getSample_const_const__InputArrayR_int_floatX(instance: *const c_void, var_idx: *const c_void, sidx: i32, buf: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_getSamples_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getMissing_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTrainSamples_const_int_bool_bool(instance: *const c_void, layout: i32, compress_samples: bool, compress_vars: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTrainResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTrainNormCatResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTestResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTestNormCatResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getNormCatResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getSampleWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTrainSampleWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTestSampleWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getVarIdx_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getVarType_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getVarSymbolFlags_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getResponseType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getTrainSampleIdx_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTestSampleIdx_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getValues_const_int_const__InputArrayR_floatX(instance: *const c_void, vi: i32, sidx: *const c_void, values: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_getNormCatValues_const_int_const__InputArrayR_intX(instance: *const c_void, vi: i32, sidx: *const c_void, values: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_getDefaultSubstValues_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getCatCount_const_int(instance: *const c_void, vi: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getClassLabels_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getCatOfs_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getCatMap_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_setTrainTestSplit_int_bool(instance: *mut c_void, count: i32, shuffle: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_setTrainTestSplitRatio_double_bool(instance: *mut c_void, ratio: f64, shuffle: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_shuffleTrainTest(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_getTestSamples_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getNames_const_vectorLStringGR(instance: *const c_void, names: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_getSubVector_const_MatR_const_MatR(vec: *const c_void, idx: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getSubMatrix_const_MatR_const_MatR_int(matrix: *const c_void, idx: *const c_void, layout: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_loadFromCSV_const_StringR_int_int_int_const_StringR_char_char(filename: *const c_char, header_line_count: i32, response_start_idx: i32, response_end_idx: i32, var_type_spec: *const c_char, delimiter: i8, missch: i8, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_create_const__InputArrayR_int_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(samples: *const c_void, layout: i32, responses: *const c_void, var_idx: *const c_void, sample_idx: *const c_void, sample_weights: *const c_void, var_type: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
	}
}
#[cfg(ocvrs_has_module_ml)]
pub use ml_sys::*;

#[cfg(ocvrs_has_module_objdetect)]
mod objdetect_sys {
	use super::*;

	extern "C" {
		pub fn cv_createFaceDetectionMaskGenerator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_groupRectangles_meanshift_vectorLRectGR_vectorLdoubleGR_vectorLdoubleGR_double_Size(rect_list: *mut c_void, found_weights: *mut c_void, found_scales: *mut c_void, detect_threshold: f64, win_det_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_int_double(rect_list: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_int_double_vectorLintGX_vectorLdoubleGX(rect_list: *mut c_void, group_threshold: i32, eps: f64, weights: *mut c_void, level_weights: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_vectorLintGR_int_double(rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_vectorLintGR_vectorLdoubleGR_int_double(rect_list: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BaseCascadeClassifier_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, num_detections: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_vectorLdoubleGR_double_int_int_Size_Size_bool(instance: *mut c_void, image: *const c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, output_reject_levels: bool, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_isOldFormatCascade_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BaseCascadeClassifier_getOriginalWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_BaseCascadeClassifier_getFeatureType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BaseCascadeClassifier_getOldCascade(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BaseCascadeClassifier_setMaskGenerator_const_PtrLMaskGeneratorGR(instance: *mut c_void, mask_generator: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_getMaskGenerator(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BaseCascadeClassifier_MaskGenerator_generateMask_const_MatR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BaseCascadeClassifier_MaskGenerator_initializeMask_const_MatR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_getPropCc(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CascadeClassifier_setPropCc_PtrLBaseCascadeClassifierG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_CascadeClassifier_CascadeClassifier(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_CascadeClassifier_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_read_const_FileNodeR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, num_detections: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_vectorLdoubleGR_double_int_int_Size_Size_bool(instance: *mut c_void, image: *const c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, output_reject_levels: bool, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_isOldFormatCascade_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_getOriginalWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_CascadeClassifier_getFeatureType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_CascadeClassifier_getOldCascade(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_convert_const_StringR_const_StringR(oldcascade: *const c_char, newcascade: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_setMaskGenerator_const_PtrLMaskGeneratorGR(instance: *mut c_void, mask_generator: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_getMaskGenerator(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_DetectionBasedTracker_PtrLIDetectorG_PtrLIDetectorG_const_ParametersR(main_detector: *mut c_void, tracking_detector: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_run(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DetectionBasedTracker_stop(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_resetTracking(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_process_const_MatR(instance: *mut c_void, image_gray: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_setParameters_const_ParametersR(instance: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DetectionBasedTracker_getParameters_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_getObjects_const_vectorLRectGR(instance: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_getObjects_const_vectorLObjectGR(instance: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_getObjects_const_vectorLExtObjectGR(instance: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_addObject_const_RectR(instance: *mut c_void, location: *const core::Rect, ocvrs_return: *mut Result<i32>);
		pub fn cv_DetectionBasedTracker_ExtObject_getPropId_const(instance: *const c_void) -> i32;
		pub fn cv_DetectionBasedTracker_ExtObject_setPropId_int(instance: *mut c_void, val: i32);
		pub fn cv_DetectionBasedTracker_ExtObject_getPropLocation_const(instance: *const c_void, ocvrs_return: *mut core::Rect);
		pub fn cv_DetectionBasedTracker_ExtObject_setPropLocation_Rect(instance: *mut c_void, val: *const core::Rect);
		pub fn cv_DetectionBasedTracker_ExtObject_getPropStatus_const(instance: *const c_void, ocvrs_return: *mut crate::objdetect::DetectionBasedTracker_ObjectStatus);
		pub fn cv_DetectionBasedTracker_ExtObject_setPropStatus_ObjectStatus(instance: *mut c_void, val: crate::objdetect::DetectionBasedTracker_ObjectStatus);
		pub fn cv_DetectionBasedTracker_ExtObject_ExtObject_int_Rect_ObjectStatus(_id: i32, _location: *const core::Rect, _status: crate::objdetect::DetectionBasedTracker_ObjectStatus, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_IDetector_detect_const_MatR_vectorLRectGR(instance: *mut c_void, image: *const c_void, objects: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_IDetector_setMinObjectSize_const_SizeR(instance: *mut c_void, min: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_IDetector_setMaxObjectSize_const_SizeR(instance: *mut c_void, max: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_IDetector_getMinObjectSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_DetectionBasedTracker_IDetector_getMaxObjectSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_DetectionBasedTracker_IDetector_getScaleFactor(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_DetectionBasedTracker_IDetector_setScaleFactor_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_IDetector_getMinNeighbours(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DetectionBasedTracker_IDetector_setMinNeighbours_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_Parameters_getPropMaxTrackLifetime_const(instance: *const c_void) -> i32;
		pub fn cv_DetectionBasedTracker_Parameters_setPropMaxTrackLifetime_int(instance: *mut c_void, val: i32);
		pub fn cv_DetectionBasedTracker_Parameters_getPropMinDetectionPeriod_const(instance: *const c_void) -> i32;
		pub fn cv_DetectionBasedTracker_Parameters_setPropMinDetectionPeriod_int(instance: *mut c_void, val: i32);
		pub fn cv_DetectionBasedTracker_Parameters_Parameters(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionROI_getPropScale_const(instance: *const c_void) -> f64;
		pub fn cv_DetectionROI_setPropScale_double(instance: *mut c_void, val: f64);
		pub fn cv_DetectionROI_getPropLocations_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_DetectionROI_setPropLocations_vectorLPointG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_DetectionROI_getPropConfidences_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_DetectionROI_setPropConfidences_vectorLdoubleG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_FaceDetectorYN_setInputSize_const_SizeR(instance: *mut c_void, input_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_FaceDetectorYN_getInputSize(instance: *mut c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_FaceDetectorYN_setScoreThreshold_float(instance: *mut c_void, score_threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_FaceDetectorYN_getScoreThreshold(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_FaceDetectorYN_setNMSThreshold_float(instance: *mut c_void, nms_threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_FaceDetectorYN_getNMSThreshold(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_FaceDetectorYN_setTopK_int(instance: *mut c_void, top_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FaceDetectorYN_getTopK(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FaceDetectorYN_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, faces: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FaceDetectorYN_create_const_StringR_const_StringR_const_SizeR_float_float_int_int_int(model: *const c_char, config: *const c_char, input_size: *const core::Size, score_threshold: f32, nms_threshold: f32, top_k: i32, backend_id: i32, target_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceRecognizerSF_alignCrop_const_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *const c_void, src_img: *const c_void, face_box: *const c_void, aligned_img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FaceRecognizerSF_feature_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, aligned_img: *const c_void, face_feature: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FaceRecognizerSF_match_const_const__InputArrayR_const__InputArrayR_int(instance: *const c_void, face_feature1: *const c_void, face_feature2: *const c_void, dis_type: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_FaceRecognizerSF_create_const_StringR_const_StringR_int_int(model: *const c_char, config: *const c_char, backend_id: i32, target_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_getPropWinSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_setPropWinSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_getPropBlockSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_setPropBlockSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_getPropBlockStride_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_setPropBlockStride_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_getPropCellSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_setPropCellSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_getPropNbins_const(instance: *const c_void) -> i32;
		pub fn cv_HOGDescriptor_setPropNbins_int(instance: *mut c_void, val: i32);
		pub fn cv_HOGDescriptor_getPropDerivAperture_const(instance: *const c_void) -> i32;
		pub fn cv_HOGDescriptor_setPropDerivAperture_int(instance: *mut c_void, val: i32);
		pub fn cv_HOGDescriptor_getPropWinSigma_const(instance: *const c_void) -> f64;
		pub fn cv_HOGDescriptor_setPropWinSigma_double(instance: *mut c_void, val: f64);
		pub fn cv_HOGDescriptor_getPropHistogramNormType_const(instance: *const c_void, ocvrs_return: *mut crate::objdetect::HOGDescriptor_HistogramNormType);
		pub fn cv_HOGDescriptor_setPropHistogramNormType_HistogramNormType(instance: *mut c_void, val: crate::objdetect::HOGDescriptor_HistogramNormType);
		pub fn cv_HOGDescriptor_getPropL2HysThreshold_const(instance: *const c_void) -> f64;
		pub fn cv_HOGDescriptor_setPropL2HysThreshold_double(instance: *mut c_void, val: f64);
		pub fn cv_HOGDescriptor_getPropGammaCorrection_const(instance: *const c_void) -> bool;
		pub fn cv_HOGDescriptor_setPropGammaCorrection_bool(instance: *mut c_void, val: bool);
		pub fn cv_HOGDescriptor_getPropSvmDetector_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_HOGDescriptor_setPropSvmDetector_vectorLfloatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_HOGDescriptor_getPropOclSvmDetector_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_HOGDescriptor_setPropOclSvmDetector_UMat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_HOGDescriptor_getPropFree_coef_const(instance: *const c_void) -> f32;
		pub fn cv_HOGDescriptor_setPropFree_coef_float(instance: *mut c_void, val: f32);
		pub fn cv_HOGDescriptor_getPropNlevels_const(instance: *const c_void) -> i32;
		pub fn cv_HOGDescriptor_setPropNlevels_int(instance: *mut c_void, val: i32);
		pub fn cv_HOGDescriptor_getPropSignedGradient_const(instance: *const c_void) -> bool;
		pub fn cv_HOGDescriptor_setPropSignedGradient_bool(instance: *mut c_void, val: bool);
		pub fn cv_HOGDescriptor_HOGDescriptor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_Size_Size_Size_Size_int_int_double_HistogramNormType_double_bool_int_bool(_win_size: *const core::Size, _block_size: *const core::Size, _block_stride: *const core::Size, _cell_size: *const core::Size, _nbins: i32, _deriv_aperture: i32, _win_sigma: f64, _histogram_norm_type: crate::objdetect::HOGDescriptor_HistogramNormType, _l2_hys_threshold: f64, _gamma_correction: bool, _nlevels: i32, _signed_gradient: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_const_HOGDescriptorR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_getDescriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_HOGDescriptor_checkDetectorSize_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_getWinSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_HOGDescriptor_setSVMDetector_const__InputArrayR(instance: *mut c_void, svmdetector: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_read_FileNodeR(instance: *mut c_void, fn_: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_write_const_FileStorageR_const_StringR(instance: *const c_void, fs: *mut c_void, objname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_load_const_StringR_const_StringR(instance: *mut c_void, filename: *const c_char, objname: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_save_const_const_StringR_const_StringR(instance: *const c_void, filename: *const c_char, objname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_copyTo_const_HOGDescriptorR(instance: *const c_void, c: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_compute_const_const__InputArrayR_vectorLfloatGR_Size_Size_const_vectorLPointGR(instance: *const c_void, img: *const c_void, descriptors: *mut c_void, win_stride: *const core::Size, padding: *const core::Size, locations: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayR_vectorLPointGR_vectorLdoubleGR_double_Size_Size_const_vectorLPointGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, weights: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, search_locations: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayR_vectorLPointGR_double_Size_Size_const_vectorLPointGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, search_locations: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayR_vectorLRectGR_vectorLdoubleGR_double_Size_Size_double_double_bool(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, found_weights: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, scale: f64, group_threshold: f64, use_meanshift_grouping: bool, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayR_vectorLRectGR_double_Size_Size_double_double_bool(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, scale: f64, group_threshold: f64, use_meanshift_grouping: bool, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_computeGradient_const_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_Size(instance: *const c_void, img: *const c_void, grad: *const c_void, angle_ofs: *const c_void, padding_tl: *const core::Size, padding_br: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_getDefaultPeopleDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_getDaimlerPeopleDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_detectROI_const_const__InputArrayR_const_vectorLPointGR_vectorLPointGR_vectorLdoubleGR_double_Size_Size(instance: *const c_void, img: *const c_void, locations: *const c_void, found_locations: *mut c_void, confidences: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detectMultiScaleROI_const_const__InputArrayR_vectorLRectGR_vectorLDetectionROIGR_double_int(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, locations: *mut c_void, hit_threshold: f64, group_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_groupRectangles_const_vectorLRectGR_vectorLdoubleGR_int_double(instance: *const c_void, rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_QRCodeDetector_QRCodeDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_setEpsX_double(instance: *mut c_void, eps_x: f64, ocvrs_return: *mut Result_void);
		pub fn cv_QRCodeDetector_setEpsY_double(instance: *mut c_void, eps_y: f64, ocvrs_return: *mut Result_void);
		pub fn cv_QRCodeDetector_detect_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_QRCodeDetector_decode_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, straight_qrcode: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_decodeCurved_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, straight_qrcode: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_detectAndDecode_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, straight_qrcode: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_detectAndDecodeCurved_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, straight_qrcode: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_detectMulti_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_QRCodeDetector_decodeMulti_const_const__InputArrayR_const__InputArrayR_vectorLstringGR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, decoded_info: *mut c_void, straight_qrcode: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_QRCodeEncoder_create_const_ParamsR(parameters: *const crate::objdetect::QRCodeEncoder_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeEncoder_encode_const_StringR_const__OutputArrayR(instance: *mut c_void, encoded_info: *const c_char, qrcode: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_QRCodeEncoder_encodeStructuredAppend_const_StringR_const__OutputArrayR(instance: *mut c_void, encoded_info: *const c_char, qrcodes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_QRCodeEncoder_Params_Params(ocvrs_return: *mut Result<crate::objdetect::QRCodeEncoder_Params>);
		pub fn cv_SimilarRects_getPropEps_const(instance: *const c_void) -> f64;
		pub fn cv_SimilarRects_setPropEps_double(instance: *mut c_void, val: f64);
		pub fn cv_SimilarRects_SimilarRects_double(_eps: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SimilarRects_operator___const_const_RectR_const_RectR(instance: *const c_void, r1: *const core::Rect, r2: *const core::Rect, ocvrs_return: *mut Result<bool>);
	}
}
#[cfg(ocvrs_has_module_objdetect)]
pub use objdetect_sys::*;

#[cfg(ocvrs_has_module_photo)]
mod photo_sys {
	use super::*;

	extern "C" {
		pub fn cv_colorChange_const__InputArrayR_const__InputArrayR_const__OutputArrayR_float_float_float(src: *const c_void, mask: *const c_void, dst: *const c_void, red_mul: f32, green_mul: f32, blue_mul: f32, ocvrs_return: *mut Result_void);
		pub fn cv_createAlignMTB_int_int_bool(max_bits: i32, exclude_range: i32, cut: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createCalibrateDebevec_int_float_bool(samples: i32, lambda: f32, random: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createCalibrateRobertson_int_float(max_iter: i32, threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createMergeDebevec(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createMergeMertens_float_float_float(contrast_weight: f32, saturation_weight: f32, exposure_weight: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createMergeRobertson(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemapDrago_float_float_float(gamma: f32, saturation: f32, bias: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemapMantiuk_float_float_float(gamma: f32, scale: f32, saturation: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemapReinhard_float_float_float_float(gamma: f32, intensity: f32, light_adapt: f32, color_adapt: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemap_float(gamma: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_fastNlMeansDenoisingColored_const__InputArrayR_const__OutputArrayR_float_float_int_int_StreamR(src: *const c_void, dst: *const c_void, h_luminance: f32, photo_render: f32, search_window: i32, block_size: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_fastNlMeansDenoising_const__InputArrayR_const__OutputArrayR_float_int_int_StreamR(src: *const c_void, dst: *const c_void, h: f32, search_window: i32, block_size: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_nonLocalMeans_const__InputArrayR_const__OutputArrayR_float_int_int_int_StreamR(src: *const c_void, dst: *const c_void, h: f32, search_window: i32, block_size: i32, border_mode: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_decolor_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, grayscale: *const c_void, color_boost: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_denoise_TVL1_const_vectorLMatGR_MatR_double_int(observations: *const c_void, result: *mut c_void, lambda: f64, niters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detailEnhance_const__InputArrayR_const__OutputArrayR_float_float(src: *const c_void, dst: *const c_void, sigma_s: f32, sigma_r: f32, ocvrs_return: *mut Result_void);
		pub fn cv_edgePreservingFilter_const__InputArrayR_const__OutputArrayR_int_float_float(src: *const c_void, dst: *const c_void, flags: i32, sigma_s: f32, sigma_r: f32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingColoredMulti_const__InputArrayR_const__OutputArrayR_int_int_float_float_int_int(src_imgs: *const c_void, dst: *const c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: f32, h_color: f32, template_window_size: i32, search_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingColored_const__InputArrayR_const__OutputArrayR_float_float_int_int(src: *const c_void, dst: *const c_void, h: f32, h_color: f32, template_window_size: i32, search_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingMulti_const__InputArrayR_const__OutputArrayR_int_int_const_vectorLfloatGR_int_int_int(src_imgs: *const c_void, dst: *const c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: *const c_void, template_window_size: i32, search_window_size: i32, norm_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingMulti_const__InputArrayR_const__OutputArrayR_int_int_float_int_int(src_imgs: *const c_void, dst: *const c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: f32, template_window_size: i32, search_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoising_const__InputArrayR_const__OutputArrayR_const_vectorLfloatGR_int_int_int(src: *const c_void, dst: *const c_void, h: *const c_void, template_window_size: i32, search_window_size: i32, norm_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoising_const__InputArrayR_const__OutputArrayR_float_int_int(src: *const c_void, dst: *const c_void, h: f32, template_window_size: i32, search_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_illuminationChange_const__InputArrayR_const__InputArrayR_const__OutputArrayR_float_float(src: *const c_void, mask: *const c_void, dst: *const c_void, alpha: f32, beta: f32, ocvrs_return: *mut Result_void);
		pub fn cv_inpaint_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_int(src: *const c_void, inpaint_mask: *const c_void, dst: *const c_void, inpaint_radius: f64, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_pencilSketch_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_float_float_float(src: *const c_void, dst1: *const c_void, dst2: *const c_void, sigma_s: f32, sigma_r: f32, shade_factor: f32, ocvrs_return: *mut Result_void);
		pub fn cv_seamlessClone_const__InputArrayR_const__InputArrayR_const__InputArrayR_Point_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, mask: *const c_void, p: *const core::Point, blend: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_stylization_const__InputArrayR_const__OutputArrayR_float_float(src: *const c_void, dst: *const c_void, sigma_s: f32, sigma_r: f32, ocvrs_return: *mut Result_void);
		pub fn cv_textureFlattening_const__InputArrayR_const__InputArrayR_const__OutputArrayR_float_float_int(src: *const c_void, mask: *const c_void, dst: *const c_void, low_threshold: f32, high_threshold: f32, kernel_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AlignExposures_process_const__InputArrayR_vectorLMatGR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *mut c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_process_const__InputArrayR_vectorLMatGR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *mut c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_process_const__InputArrayR_vectorLMatGR(instance: *mut c_void, src: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_calculateShift_const__InputArrayR_const__InputArrayR(instance: *mut c_void, img0: *const c_void, img1: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_AlignMTB_shiftMat_const__InputArrayR_const__OutputArrayR_const_Point(instance: *mut c_void, src: *const c_void, dst: *const c_void, shift: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_computeBitmaps_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, tb: *const c_void, eb: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_getMaxBits_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AlignMTB_setMaxBits_int(instance: *mut c_void, max_bits: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_getExcludeRange_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AlignMTB_setExcludeRange_int(instance: *mut c_void, exclude_range: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_getCut_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_AlignMTB_setCut_bool(instance: *mut c_void, value: bool, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateCRF_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateDebevec_getLambda_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_CalibrateDebevec_setLambda_float(instance: *mut c_void, lambda: f32, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateDebevec_getSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_CalibrateDebevec_setSamples_int(instance: *mut c_void, samples: i32, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateDebevec_getRandom_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CalibrateDebevec_setRandom_bool(instance: *mut c_void, random: bool, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateRobertson_getMaxIter_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_CalibrateRobertson_setMaxIter_int(instance: *mut c_void, max_iter: i32, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateRobertson_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_CalibrateRobertson_setThreshold_float(instance: *mut c_void, threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateRobertson_getRadiance_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MergeDebevec_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeDebevec_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeExposures_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeMertens_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeMertens_process_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeMertens_getContrastWeight_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_MergeMertens_setContrastWeight_float(instance: *mut c_void, contrast_weiht: f32, ocvrs_return: *mut Result_void);
		pub fn cv_MergeMertens_getSaturationWeight_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_MergeMertens_setSaturationWeight_float(instance: *mut c_void, saturation_weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_MergeMertens_getExposureWeight_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_MergeMertens_setExposureWeight_float(instance: *mut c_void, exposure_weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_MergeRobertson_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeRobertson_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Tonemap_process_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Tonemap_getGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_Tonemap_setGamma_float(instance: *mut c_void, gamma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapDrago_getSaturation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapDrago_setSaturation_float(instance: *mut c_void, saturation: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapDrago_getBias_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapDrago_setBias_float(instance: *mut c_void, bias: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapMantiuk_getScale_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapMantiuk_setScale_float(instance: *mut c_void, scale: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapMantiuk_getSaturation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapMantiuk_setSaturation_float(instance: *mut c_void, saturation: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapReinhard_getIntensity_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapReinhard_setIntensity_float(instance: *mut c_void, intensity: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapReinhard_getLightAdaptation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapReinhard_setLightAdaptation_float(instance: *mut c_void, light_adapt: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapReinhard_getColorAdaptation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapReinhard_setColorAdaptation_float(instance: *mut c_void, color_adapt: f32, ocvrs_return: *mut Result_void);
	}
}
#[cfg(ocvrs_has_module_photo)]
pub use photo_sys::*;

#[cfg(ocvrs_has_module_stitching)]
mod stitching_sys {
	use super::*;

	extern "C" {
		pub fn cv_detail_autoDetectWaveCorrectKind_const_vectorLMatGR(rmats: *const c_void, ocvrs_return: *mut Result<crate::stitching::Detail_WaveCorrectKind>);
		pub fn cv_detail_computeImageFeatures_const_PtrLFeature2DGR_const__InputArrayR_ImageFeaturesR_const__InputArrayR(features_finder: *const c_void, image: *const c_void, features: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_computeImageFeatures_const_PtrLFeature2DGR_const__InputArrayR_vectorLImageFeaturesGR_const__InputArrayR(features_finder: *const c_void, images: *const c_void, features: *mut c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_createLaplacePyrGpu_const__InputArrayR_int_vectorLUMatGR(img: *const c_void, num_levels: i32, pyr: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_createLaplacePyr_const__InputArrayR_int_vectorLUMatGR(img: *const c_void, num_levels: i32, pyr: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_createWeightMap_const__InputArrayR_float_const__InputOutputArrayR(mask: *const c_void, sharpness: f32, weight: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_findMaxSpanningTree_int_const_vectorLMatchesInfoGR_GraphR_vectorLintGR(num_images: i32, pairwise_matches: *const c_void, span_tree: *mut c_void, centers: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_leaveBiggestComponent_vectorLImageFeaturesGR_vectorLMatchesInfoGR_float(features: *mut c_void, pairwise_matches: *mut c_void, conf_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_matchesGraphAsString_vectorLStringGR_vectorLMatchesInfoGR_float(pathes: *mut c_void, pairwise_matches: *mut c_void, conf_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_normalizeUsingWeightMap_const__InputArrayR_const__InputOutputArrayR(weight: *const c_void, src: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_overlapRoi_Point_Point_Size_Size_RectR(tl1: *const core::Point, tl2: *const core::Point, sz1: *const core::Size, sz2: *const core::Size, roi: *mut core::Rect, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_restoreImageFromLaplacePyrGpu_vectorLUMatGR(pyr: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_restoreImageFromLaplacePyr_vectorLUMatGR(pyr: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_resultRoiIntersection_const_vectorLPointGR_const_vectorLSizeGR(corners: *const c_void, sizes: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_resultRoi_const_vectorLPointGR_const_vectorLSizeGR(corners: *const c_void, sizes: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_resultRoi_const_vectorLPointGR_const_vectorLUMatGR(corners: *const c_void, images: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_resultTl_const_vectorLPointGR(corners: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_selectRandomSubset_int_int_vectorLintGR(count: i32, size: i32, subset: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_stitchingLogLevel(ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_waveCorrect_vectorLMatGR_WaveCorrectKind(rmats: *mut c_void, kind: crate::stitching::Detail_WaveCorrectKind, ocvrs_return: *mut Result_void);
		pub fn cv_AffineWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CompressedRectilinearPortraitWarper_CompressedRectilinearPortraitWarper_float_float(a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CompressedRectilinearPortraitWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CompressedRectilinearWarper_CompressedRectilinearWarper_float_float(a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CompressedRectilinearWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CylindricalWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FisheyeWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MercatorWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PaniniPortraitWarper_PaniniPortraitWarper_float_float(a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PaniniPortraitWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PaniniWarper_PaniniWarper_float_float(a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PaniniWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PlaneWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PyRotationWarper_PyRotationWarper_String_float(typ: *mut c_char, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PyRotationWarper_PyRotationWarper(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PyRotationWarper_warpPoint_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_PyRotationWarper_warpPointBackward_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_PyRotationWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_PyRotationWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_PyRotationWarper_warpBackward_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_Size_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst_size: *const core::Size, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PyRotationWarper_warpRoi_Size_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_PyRotationWarper_getScale_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_PyRotationWarper_setScale_float(instance: *mut c_void, unnamed: f32, ocvrs_return: *mut Result_void);
		pub fn cv_SphericalWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_StereographicWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_create_Mode(mode: crate::stitching::Stitcher_Mode, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_registrationResol_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Stitcher_setRegistrationResol_double(instance: *mut c_void, resol_mpx: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_seamEstimationResol_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Stitcher_setSeamEstimationResol_double(instance: *mut c_void, resol_mpx: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_compositingResol_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Stitcher_setCompositingResol_double(instance: *mut c_void, resol_mpx: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_panoConfidenceThresh_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Stitcher_setPanoConfidenceThresh_double(instance: *mut c_void, conf_thresh: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_waveCorrection_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Stitcher_setWaveCorrection_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_interpolationFlags_const(instance: *const c_void, ocvrs_return: *mut Result<crate::imgproc::InterpolationFlags>);
		pub fn cv_Stitcher_setInterpolationFlags_InterpolationFlags(instance: *mut c_void, interp_flags: crate::imgproc::InterpolationFlags, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_waveCorrectKind_const(instance: *const c_void, ocvrs_return: *mut Result<crate::stitching::Detail_WaveCorrectKind>);
		pub fn cv_Stitcher_setWaveCorrectKind_WaveCorrectKind(instance: *mut c_void, kind: crate::stitching::Detail_WaveCorrectKind, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_featuresFinder(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_featuresFinder_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setFeaturesFinder_PtrLFeature2DG(instance: *mut c_void, features_finder: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_featuresMatcher(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_featuresMatcher_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setFeaturesMatcher_PtrLFeaturesMatcherG(instance: *mut c_void, features_matcher: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_matchingMask_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setMatchingMask_const_UMatR(instance: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_bundleAdjuster(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_bundleAdjuster_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setBundleAdjuster_PtrLBundleAdjusterBaseG(instance: *mut c_void, bundle_adjuster: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_estimator(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_estimator_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setEstimator_PtrLEstimatorG(instance: *mut c_void, estimator: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_warper(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_warper_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setWarper_PtrLWarperCreatorG(instance: *mut c_void, creator: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_exposureCompensator(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_exposureCompensator_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setExposureCompensator_PtrLExposureCompensatorG(instance: *mut c_void, exposure_comp: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_seamFinder(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_seamFinder_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setSeamFinder_PtrLSeamFinderG(instance: *mut c_void, seam_finder: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_blender(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_blender_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setBlender_PtrLBlenderG(instance: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_estimateTransform_const__InputArrayR_const__InputArrayR(instance: *mut c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_setTransform_const__InputArrayR_const_vectorLCameraParamsGR_const_vectorLintGR(instance: *mut c_void, images: *const c_void, cameras: *const c_void, component: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_setTransform_const__InputArrayR_const_vectorLCameraParamsGR(instance: *mut c_void, images: *const c_void, cameras: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_composePanorama_const__OutputArrayR(instance: *mut c_void, pano: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_composePanorama_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, pano: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_stitch_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, pano: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_stitch_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, masks: *const c_void, pano: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_component_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_cameras_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_workScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Stitcher_resultMask_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TransverseMercatorWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_WarperCreator_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_AffineBasedEstimator_AffineBasedEstimator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_AffineBestOf2NearestMatcher_AffineBestOf2NearestMatcher_bool_bool_float_int(full_affine: bool, try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_AffineWarper_AffineWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_AffineWarper_warpPoint_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, h: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_AffineWarper_warpPointBackward_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, h: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_AffineWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, h: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_AffineWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, h: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_AffineWarper_warpRoi_Size_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, h: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_BestOf2NearestMatcher_BestOf2NearestMatcher_bool_float_int_int(try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, num_matches_thresh2: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BestOf2NearestMatcher_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BestOf2NearestMatcher_create_bool_float_int_int(try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, num_matches_thresh2: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BestOf2NearestRangeMatcher_BestOf2NearestRangeMatcher_int_bool_float_int_int(range_width: i32, try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, num_matches_thresh2: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BestOf2NearestRangeMatcher_operator___const_vectorLImageFeaturesGR_vectorLMatchesInfoGR_const_UMatR(instance: *mut c_void, features: *const c_void, pairwise_matches: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Blender_createDefault_int_bool(typ: i32, try_gpu: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_Blender_prepare_const_vectorLPointGR_const_vectorLSizeGR(instance: *mut c_void, corners: *const c_void, sizes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Blender_prepare_Rect(instance: *mut c_void, dst_roi: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Blender_feed_const__InputArrayR_const__InputArrayR_Point(instance: *mut c_void, img: *const c_void, mask: *const c_void, tl: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Blender_blend_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, dst: *const c_void, dst_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksChannelsCompensator_BlocksChannelsCompensator_int_int_int(bl_width: i32, bl_height: i32, nr_feeds: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BlocksChannelsCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, index: i32, corner: *const core::Point, image: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_setNrFeeds_int(instance: *mut c_void, nr_feeds: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_getNrFeeds(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_BlocksCompensator_setSimilarityThreshold_double(instance: *mut c_void, similarity_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_getSimilarityThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_detail_BlocksCompensator_setBlockSize_int_int(instance: *mut c_void, width: i32, height: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_setBlockSize_Size(instance: *mut c_void, size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_getBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_detail_BlocksCompensator_setNrGainsFilteringIterations_int(instance: *mut c_void, nr_iterations: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_getNrGainsFilteringIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_BlocksGainCompensator_BlocksGainCompensator_int_int(bl_width: i32, bl_height: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BlocksGainCompensator_BlocksGainCompensator_int_int_int(bl_width: i32, bl_height: i32, nr_feeds: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BlocksGainCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksGainCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, index: i32, corner: *const core::Point, image: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksGainCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksGainCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BundleAdjusterAffine_BundleAdjusterAffine(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BundleAdjusterAffinePartial_BundleAdjusterAffinePartial(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BundleAdjusterBase_refinementMask_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BundleAdjusterBase_setRefinementMask_const_MatR(instance: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BundleAdjusterBase_confThresh_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_detail_BundleAdjusterBase_setConfThresh_double(instance: *mut c_void, conf_thresh: f64, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BundleAdjusterBase_termCriteria(instance: *mut c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_detail_BundleAdjusterBase_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, term_criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BundleAdjusterRay_BundleAdjusterRay(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BundleAdjusterReproj_BundleAdjusterReproj(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CameraParams_getPropFocal_const(instance: *const c_void) -> f64;
		pub fn cv_detail_CameraParams_setPropFocal_double(instance: *mut c_void, val: f64);
		pub fn cv_detail_CameraParams_getPropAspect_const(instance: *const c_void) -> f64;
		pub fn cv_detail_CameraParams_setPropAspect_double(instance: *mut c_void, val: f64);
		pub fn cv_detail_CameraParams_getPropPpx_const(instance: *const c_void) -> f64;
		pub fn cv_detail_CameraParams_setPropPpx_double(instance: *mut c_void, val: f64);
		pub fn cv_detail_CameraParams_getPropPpy_const(instance: *const c_void) -> f64;
		pub fn cv_detail_CameraParams_setPropPpy_double(instance: *mut c_void, val: f64);
		pub fn cv_detail_CameraParams_getPropR_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CameraParams_setPropR_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_CameraParams_getPropT_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CameraParams_setPropT_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_CameraParams_CameraParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CameraParams_CameraParams_const_CameraParamsR(other: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CameraParams_K_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ChannelsCompensator_ChannelsCompensator_int(nr_feeds: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ChannelsCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, index: i32, corner: *const core::Point, image: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_setNrFeeds_int(instance: *mut c_void, nr_feeds: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_getNrFeeds(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_ChannelsCompensator_setSimilarityThreshold_double(instance: *mut c_void, similarity_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_getSimilarityThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_detail_ChannelsCompensator_gains_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CompressedRectilinearPortraitProjector_getPropA_const(instance: *const c_void) -> f32;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_setPropA_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_CompressedRectilinearPortraitProjector_getPropB_const(instance: *const c_void) -> f32;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_setPropB_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_CompressedRectilinearPortraitProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CompressedRectilinearPortraitProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CompressedRectilinearPortraitWarper_CompressedRectilinearPortraitWarper_float_float_float(scale: f32, a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CompressedRectilinearProjector_getPropA_const(instance: *const c_void) -> f32;
		pub fn cv_detail_CompressedRectilinearProjector_setPropA_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_CompressedRectilinearProjector_getPropB_const(instance: *const c_void) -> f32;
		pub fn cv_detail_CompressedRectilinearProjector_setPropB_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_CompressedRectilinearProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CompressedRectilinearProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CompressedRectilinearWarper_CompressedRectilinearWarper_float_float_float(scale: f32, a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CylindricalPortraitProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CylindricalPortraitProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CylindricalPortraitWarper_CylindricalPortraitWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CylindricalProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CylindricalProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CylindricalWarper_CylindricalWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CylindricalWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_CylindricalWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_CylindricalWarperGpu_CylindricalWarperGpu_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CylindricalWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_CylindricalWarperGpu_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_CylindricalWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_GpuMatR_GpuMatR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_CylindricalWarperGpu_warp_const_GpuMatR_const__InputArrayR_const__InputArrayR_int_int_GpuMatR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_DisjointSets_getPropParent_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_DisjointSets_setPropParent_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_DisjointSets_getPropSize_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_DisjointSets_setPropSize_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_DisjointSets_DisjointSets_int(elem_count: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_DisjointSets_createOneElemSets_int(instance: *mut c_void, elem_count: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_DisjointSets_findSetByElem_int(instance: *mut c_void, elem: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_DisjointSets_mergeSets_int_int(instance: *mut c_void, set1: i32, set2: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_DpSeamFinder_DpSeamFinder_CostFunction(cost_func: crate::stitching::Detail_DpSeamFinder_CostFunction, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_DpSeamFinder_DpSeamFinder_String(cost_func: *mut c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_DpSeamFinder_costFunction_const(instance: *const c_void, ocvrs_return: *mut Result<crate::stitching::Detail_DpSeamFinder_CostFunction>);
		pub fn cv_detail_DpSeamFinder_setCostFunction_CostFunction(instance: *mut c_void, val: crate::stitching::Detail_DpSeamFinder_CostFunction, ocvrs_return: *mut Result_void);
		pub fn cv_detail_DpSeamFinder_setCostFunction_String(instance: *mut c_void, val: *mut c_char, ocvrs_return: *mut Result_void);
		pub fn cv_detail_DpSeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Estimator_operator___const_vectorLImageFeaturesGR_const_vectorLMatchesInfoGR_vectorLCameraParamsGR(instance: *mut c_void, features: *const c_void, pairwise_matches: *const c_void, cameras: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_ExposureCompensator_createDefault_int(typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ExposureCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLUMatGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, index: i32, corner: *const core::Point, image: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_setUpdateGain_bool(instance: *mut c_void, b: bool, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_getUpdateGain(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_FeatherBlender_FeatherBlender_float(sharpness: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_FeatherBlender_sharpness_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_detail_FeatherBlender_setSharpness_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeatherBlender_prepare_Rect(instance: *mut c_void, dst_roi: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeatherBlender_feed_const__InputArrayR_const__InputArrayR_Point(instance: *mut c_void, img: *const c_void, mask: *const c_void, tl: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeatherBlender_blend_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, dst: *const c_void, dst_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeatherBlender_createWeightMaps_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, masks: *const c_void, corners: *const c_void, weight_maps: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_FeaturesMatcher_operator___const_ImageFeaturesR_const_ImageFeaturesR_MatchesInfoR(instance: *mut c_void, features1: *const c_void, features2: *const c_void, matches_info: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeaturesMatcher_operator___const_vectorLImageFeaturesGR_vectorLMatchesInfoGR_const_UMatR(instance: *mut c_void, features: *const c_void, pairwise_matches: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeaturesMatcher_isThreadSafe_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_FeaturesMatcher_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FisheyeProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FisheyeProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FisheyeWarper_FisheyeWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GainCompensator_GainCompensator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GainCompensator_GainCompensator_int(nr_feeds: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GainCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_singleFeed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, index: i32, corner: *const core::Point, image: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_setNrFeeds_int(instance: *mut c_void, nr_feeds: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_getNrFeeds(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_GainCompensator_setSimilarityThreshold_double(instance: *mut c_void, similarity_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_getSimilarityThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_detail_GainCompensator_prepareSimilarityMask_const_vectorLPointGR_const_vectorLUMatGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_gains_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_Graph_Graph_int(num_vertices: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_Graph_create_int(instance: *mut c_void, num_vertices: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Graph_numVertices_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_Graph_addEdge_int_int_float(instance: *mut c_void, from: i32, to: i32, weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder_int_float_float(cost_type: i32, terminal_cost: f32, bad_region_penalty: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder_String_float_float(cost_type: *mut c_char, terminal_cost: f32, bad_region_penalty: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GraphCutSeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GraphEdge_getPropFrom_const(instance: *const c_void) -> i32;
		pub fn cv_detail_GraphEdge_setPropFrom_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_GraphEdge_getPropTo_const(instance: *const c_void) -> i32;
		pub fn cv_detail_GraphEdge_setPropTo_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_GraphEdge_getPropWeight_const(instance: *const c_void) -> f32;
		pub fn cv_detail_GraphEdge_setPropWeight_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_GraphEdge_GraphEdge_int_int_float(from: i32, to: i32, weight: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GraphEdge_operatorL_const_const_GraphEdgeR(instance: *const c_void, other: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_GraphEdge_operatorG_const_const_GraphEdgeR(instance: *const c_void, other: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_HomographyBasedEstimator_HomographyBasedEstimator_bool(is_focals_estimated: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ImageFeatures_getPropImg_idx_const(instance: *const c_void) -> i32;
		pub fn cv_detail_ImageFeatures_setPropImg_idx_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_ImageFeatures_getPropImg_size_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_detail_ImageFeatures_setPropImg_size_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_detail_ImageFeatures_getPropKeypoints_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_ImageFeatures_setPropKeypoints_vectorLKeyPointG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_ImageFeatures_getPropDescriptors_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_ImageFeatures_setPropDescriptors_UMat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_ImageFeatures_getKeypoints(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MatchesInfo_getPropSrc_img_idx_const(instance: *const c_void) -> i32;
		pub fn cv_detail_MatchesInfo_setPropSrc_img_idx_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_MatchesInfo_getPropDst_img_idx_const(instance: *const c_void) -> i32;
		pub fn cv_detail_MatchesInfo_setPropDst_img_idx_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_MatchesInfo_getPropMatches_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_MatchesInfo_setPropMatches_vectorLDMatchG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_MatchesInfo_getPropInliers_mask_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_MatchesInfo_setPropInliers_mask_vectorLunsigned_charG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_MatchesInfo_getPropNum_inliers_const(instance: *const c_void) -> i32;
		pub fn cv_detail_MatchesInfo_setPropNum_inliers_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_MatchesInfo_getPropH_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_MatchesInfo_setPropH_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_MatchesInfo_getPropConfidence_const(instance: *const c_void) -> f64;
		pub fn cv_detail_MatchesInfo_setPropConfidence_double(instance: *mut c_void, val: f64);
		pub fn cv_detail_MatchesInfo_MatchesInfo(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MatchesInfo_MatchesInfo_const_MatchesInfoR(other: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MatchesInfo_getMatches(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MatchesInfo_getInliers(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MercatorProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MercatorProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MercatorWarper_MercatorWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MultiBandBlender_MultiBandBlender_int_int_int(try_gpu: i32, num_bands: i32, weight_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MultiBandBlender_numBands_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_MultiBandBlender_setNumBands_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MultiBandBlender_prepare_Rect(instance: *mut c_void, dst_roi: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MultiBandBlender_feed_const__InputArrayR_const__InputArrayR_Point(instance: *mut c_void, img: *const c_void, mask: *const c_void, tl: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MultiBandBlender_blend_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, dst: *const c_void, dst_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_NoBundleAdjuster_NoBundleAdjuster(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_NoExposureCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, unnamed: *const c_void, unnamed_1: *const c_void, unnamed_2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_NoExposureCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, unnamed: i32, unnamed_1: *const core::Point, unnamed_2: *const c_void, unnamed_3: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_NoExposureCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_NoExposureCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_NoSeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, unnamed: *const c_void, unnamed_1: *const c_void, unnamed_2: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PairwiseSeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PaniniPortraitProjector_getPropA_const(instance: *const c_void) -> f32;
		pub fn cv_detail_PaniniPortraitProjector_setPropA_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_PaniniPortraitProjector_getPropB_const(instance: *const c_void) -> f32;
		pub fn cv_detail_PaniniPortraitProjector_setPropB_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_PaniniPortraitProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PaniniPortraitProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PaniniPortraitWarper_PaniniPortraitWarper_float_float_float(scale: f32, a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PaniniProjector_getPropA_const(instance: *const c_void) -> f32;
		pub fn cv_detail_PaniniProjector_setPropA_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_PaniniProjector_getPropB_const(instance: *const c_void) -> f32;
		pub fn cv_detail_PaniniProjector_setPropB_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_PaniniProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PaniniProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PaniniWarper_PaniniWarper_float_float_float(scale: f32, a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PlanePortraitProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PlanePortraitProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PlanePortraitWarper_PlanePortraitWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PlaneProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PlaneProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PlaneWarper_PlaneWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PlaneWarper_warpPoint_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_PlaneWarper_warpPoint_const_Point2fR_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_PlaneWarper_warpPointBackward_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_PlaneWarper_warpPointBackward_const_Point2fR_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_PlaneWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, t: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, t: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarper_warpRoi_Size_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarper_warpRoi_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarperGpu_PlaneWarperGpu_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PlaneWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, t: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarperGpu_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarperGpu_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, t: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_GpuMatR_GpuMatR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR_GpuMatR_GpuMatR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, t: *const c_void, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarperGpu_warp_const_GpuMatR_const__InputArrayR_const__InputArrayR_int_int_GpuMatR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarperGpu_warp_const_GpuMatR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_GpuMatR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, t: *const c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_ProjectorBase_getPropScale_const(instance: *const c_void) -> f32;
		pub fn cv_detail_ProjectorBase_setPropScale_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_ProjectorBase_getPropK(instance: *mut c_void) -> *mut [f32; 9];
		pub fn cv_detail_ProjectorBase_getPropRinv(instance: *mut c_void) -> *mut [f32; 9];
		pub fn cv_detail_ProjectorBase_getPropR_kinv(instance: *mut c_void) -> *mut [f32; 9];
		pub fn cv_detail_ProjectorBase_getPropK_rinv(instance: *mut c_void) -> *mut [f32; 9];
		pub fn cv_detail_ProjectorBase_getPropT(instance: *mut c_void) -> *mut [f32; 3];
		pub fn cv_detail_ProjectorBase_setCameraParams_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, k: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_RotationWarper_warpPoint_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_RotationWarper_warpPointBackward_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_RotationWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_RotationWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_RotationWarper_warpBackward_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_Size_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst_size: *const core::Size, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_RotationWarper_warpRoi_Size_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_RotationWarper_getScale_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_detail_RotationWarper_setScale_float(instance: *mut c_void, unnamed: f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SeamFinder_createDefault_int(typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_SphericalPortraitProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SphericalPortraitProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SphericalPortraitWarper_SphericalPortraitWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_SphericalProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SphericalProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SphericalWarper_SphericalWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_SphericalWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_SphericalWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_SphericalWarperGpu_SphericalWarperGpu_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_SphericalWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_SphericalWarperGpu_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_SphericalWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_GpuMatR_GpuMatR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_SphericalWarperGpu_warp_const_GpuMatR_const__InputArrayR_const__InputArrayR_int_int_GpuMatR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_StereographicProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_StereographicProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_StereographicWarper_StereographicWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_TransverseMercatorProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_TransverseMercatorProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_TransverseMercatorWarper_TransverseMercatorWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_VoronoiSeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_VoronoiSeamFinder_find_const_vectorLSizeGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, size: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
	}
}
#[cfg(ocvrs_has_module_stitching)]
pub use stitching_sys::*;

#[cfg(ocvrs_has_module_video)]
mod video_sys {
	use super::*;

	extern "C" {
		pub fn cv_CamShift_const__InputArrayR_RectR_TermCriteria(prob_image: *const c_void, window: *mut core::Rect, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_buildOpticalFlowPyramid_const__InputArrayR_const__OutputArrayR_Size_int_bool_int_int_bool(img: *const c_void, pyramid: *const c_void, win_size: *const core::Size, max_level: i32, with_derivatives: bool, pyr_border: i32, deriv_border: i32, try_reuse_input_image: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_calcOpticalFlowFarneback_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_double_int_int_int_int_double_int(prev: *const c_void, next: *const c_void, flow: *const c_void, pyr_scale: f64, levels: i32, winsize: i32, iterations: i32, poly_n: i32, poly_sigma: f64, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_calcOpticalFlowPyrLK_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_Size_int_TermCriteria_int_double(prev_img: *const c_void, next_img: *const c_void, prev_pts: *const c_void, next_pts: *const c_void, status: *const c_void, err: *const c_void, win_size: *const core::Size, max_level: i32, criteria: *const core::TermCriteria, flags: i32, min_eig_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_computeECC_const__InputArrayR_const__InputArrayR_const__InputArrayR(template_image: *const c_void, input_image: *const c_void, input_mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_createBackgroundSubtractorKNN_int_double_bool(history: i32, dist2_threshold: f64, detect_shadows: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createBackgroundSubtractorMOG2_int_double_bool(history: i32, var_threshold: f64, detect_shadows: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateRigidTransform_const__InputArrayR_const__InputArrayR_bool(src: *const c_void, dst: *const c_void, full_affine: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findTransformECC_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_int_TermCriteria_const__InputArrayR(template_image: *const c_void, input_image: *const c_void, warp_matrix: *const c_void, motion_type: i32, criteria: *const core::TermCriteria, input_mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_findTransformECC_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_int_TermCriteria_const__InputArrayR_int(template_image: *const c_void, input_image: *const c_void, warp_matrix: *const c_void, motion_type: i32, criteria: *const core::TermCriteria, input_mask: *const c_void, gauss_filt_size: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_meanShift_const__InputArrayR_RectR_TermCriteria(prob_image: *const c_void, window: *mut core::Rect, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<i32>);
		pub fn cv_readOpticalFlow_const_StringR(path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_writeOpticalFlow_const_StringR_const__InputArrayR(path: *const c_char, flow: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BackgroundSubtractor_apply_const__InputArrayR_const__OutputArrayR_double(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, learning_rate: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractor_getBackgroundImage_const_const__OutputArrayR(instance: *const c_void, background_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getHistory_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorKNN_setHistory_int(instance: *mut c_void, history: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getNSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorKNN_setNSamples_int(instance: *mut c_void, _n_n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getDist2Threshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorKNN_setDist2Threshold_double(instance: *mut c_void, _dist2_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getkNNSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorKNN_setkNNSamples_int(instance: *mut c_void, _nk_nn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getDetectShadows_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BackgroundSubtractorKNN_setDetectShadows_bool(instance: *mut c_void, detect_shadows: bool, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getShadowValue_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorKNN_setShadowValue_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getShadowThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorKNN_setShadowThreshold_double(instance: *mut c_void, threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getHistory_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorMOG2_setHistory_int(instance: *mut c_void, history: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getNMixtures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorMOG2_setNMixtures_int(instance: *mut c_void, nmixtures: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getBackgroundRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setBackgroundRatio_double(instance: *mut c_void, ratio: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getVarThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setVarThreshold_double(instance: *mut c_void, var_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getVarThresholdGen_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setVarThresholdGen_double(instance: *mut c_void, var_threshold_gen: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getVarInit_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setVarInit_double(instance: *mut c_void, var_init: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getVarMin_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setVarMin_double(instance: *mut c_void, var_min: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getVarMax_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setVarMax_double(instance: *mut c_void, var_max: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getComplexityReductionThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setComplexityReductionThreshold_double(instance: *mut c_void, ct: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getDetectShadows_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BackgroundSubtractorMOG2_setDetectShadows_bool(instance: *mut c_void, detect_shadows: bool, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getShadowValue_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorMOG2_setShadowValue_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getShadowThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setShadowThreshold_double(instance: *mut c_void, threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_apply_const__InputArrayR_const__OutputArrayR_double(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, learning_rate: f64, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getFinestScale_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DISOpticalFlow_setFinestScale_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getPatchSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DISOpticalFlow_setPatchSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getPatchStride_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DISOpticalFlow_setPatchStride_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getGradientDescentIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DISOpticalFlow_setGradientDescentIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getVariationalRefinementIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DISOpticalFlow_setVariationalRefinementIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getVariationalRefinementAlpha_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_DISOpticalFlow_setVariationalRefinementAlpha_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getVariationalRefinementDelta_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_DISOpticalFlow_setVariationalRefinementDelta_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getVariationalRefinementGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_DISOpticalFlow_setVariationalRefinementGamma_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getUseMeanNormalization_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DISOpticalFlow_setUseMeanNormalization_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getUseSpatialPropagation_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DISOpticalFlow_setUseSpatialPropagation_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_create_int(preset: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DenseOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(instance: *mut c_void, i0: *const c_void, i1: *const c_void, flow: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DenseOpticalFlow_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getNumLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FarnebackOpticalFlow_setNumLevels_int(instance: *mut c_void, num_levels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getPyrScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FarnebackOpticalFlow_setPyrScale_double(instance: *mut c_void, pyr_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getFastPyramids_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FarnebackOpticalFlow_setFastPyramids_bool(instance: *mut c_void, fast_pyramids: bool, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getWinSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FarnebackOpticalFlow_setWinSize_int(instance: *mut c_void, win_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getNumIters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FarnebackOpticalFlow_setNumIters_int(instance: *mut c_void, num_iters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getPolyN_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FarnebackOpticalFlow_setPolyN_int(instance: *mut c_void, poly_n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getPolySigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FarnebackOpticalFlow_setPolySigma_double(instance: *mut c_void, poly_sigma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getFlags_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FarnebackOpticalFlow_setFlags_int(instance: *mut c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_create_int_double_bool_int_int_int_double_int(num_levels: i32, pyr_scale: f64, fast_pyramids: bool, win_size: i32, num_iters: i32, poly_n: i32, poly_sigma: f64, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KalmanFilter_getPropStatePre_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropStatePre_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropStatePost_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropStatePost_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropTransitionMatrix_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropTransitionMatrix_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropControlMatrix_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropControlMatrix_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropMeasurementMatrix_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropMeasurementMatrix_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropProcessNoiseCov_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropProcessNoiseCov_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropMeasurementNoiseCov_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropMeasurementNoiseCov_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropErrorCovPre_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropErrorCovPre_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropGain_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropGain_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropErrorCovPost_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropErrorCovPost_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropTemp1_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropTemp1_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropTemp2_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropTemp2_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropTemp3_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropTemp3_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropTemp4_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropTemp4_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_getPropTemp5_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_setPropTemp5_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_KalmanFilter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KalmanFilter_KalmanFilter_int_int_int_int(dynam_params: i32, measure_params: i32, control_params: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KalmanFilter_init_int_int_int_int(instance: *mut c_void, dynam_params: i32, measure_params: i32, control_params: i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KalmanFilter_predict_const_MatR(instance: *mut c_void, control: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KalmanFilter_correct_const_MatR(instance: *mut c_void, measurement: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, prev_img: *const c_void, next_img: *const c_void, prev_pts: *const c_void, next_pts: *const c_void, status: *const c_void, err: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_getWinSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_SparsePyrLKOpticalFlow_setWinSize_Size(instance: *mut c_void, win_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_getMaxLevel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_SparsePyrLKOpticalFlow_setMaxLevel_int(instance: *mut c_void, max_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_SparsePyrLKOpticalFlow_setTermCriteria_TermCriteriaR(instance: *mut c_void, crit: *mut core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_getFlags_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_SparsePyrLKOpticalFlow_setFlags_int(instance: *mut c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_getMinEigThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_SparsePyrLKOpticalFlow_setMinEigThreshold_double(instance: *mut c_void, min_eig_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_create_Size_int_TermCriteria_int_double(win_size: *const core::Size, max_level: i32, crit: *const core::TermCriteria, flags: i32, min_eig_threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Tracker_init_const__InputArrayR_const_RectR(instance: *mut c_void, image: *const c_void, bounding_box: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_Tracker_update_const__InputArrayR_RectR(instance: *mut c_void, image: *const c_void, bounding_box: *mut core::Rect, ocvrs_return: *mut Result<bool>);
		pub fn cv_TrackerDaSiamRPN_create_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerDaSiamRPN_getTrackingScore(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TrackerDaSiamRPN_Params_getPropModel_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerDaSiamRPN_Params_setPropModel_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerDaSiamRPN_Params_getPropKernel_cls1_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerDaSiamRPN_Params_setPropKernel_cls1_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerDaSiamRPN_Params_getPropKernel_r1_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerDaSiamRPN_Params_setPropKernel_r1_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerDaSiamRPN_Params_getPropBackend_const(instance: *const c_void) -> i32;
		pub fn cv_TrackerDaSiamRPN_Params_setPropBackend_int(instance: *mut c_void, val: i32);
		pub fn cv_TrackerDaSiamRPN_Params_getPropTarget_const(instance: *const c_void) -> i32;
		pub fn cv_TrackerDaSiamRPN_Params_setPropTarget_int(instance: *mut c_void, val: i32);
		pub fn cv_TrackerDaSiamRPN_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerGOTURN_create_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerGOTURN_Params_getPropModelTxt_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerGOTURN_Params_setPropModelTxt_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerGOTURN_Params_getPropModelBin_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerGOTURN_Params_setPropModelBin_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerGOTURN_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerMIL_create_const_ParamsR(parameters: *const crate::video::TrackerMIL_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerMIL_Params_Params(ocvrs_return: *mut Result<crate::video::TrackerMIL_Params>);
		pub fn cv_VariationalRefinement_calcUV_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, i0: *const c_void, i1: *const c_void, flow_u: *const c_void, flow_v: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getFixedPointIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_VariationalRefinement_setFixedPointIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getSorIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_VariationalRefinement_setSorIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getOmega_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_VariationalRefinement_setOmega_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getAlpha_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_VariationalRefinement_setAlpha_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getDelta_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_VariationalRefinement_setDelta_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_VariationalRefinement_setGamma_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_create(ocvrs_return: *mut Result<*mut c_void>);
	}
}
#[cfg(ocvrs_has_module_video)]
pub use video_sys::*;

#[cfg(ocvrs_has_module_videoio)]
mod videoio_sys {
	use super::*;

	extern "C" {
		pub fn cv_videoio_registry_getBackendName_VideoCaptureAPIs(api: crate::videoio::VideoCaptureAPIs, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getBackends(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getCameraBackendPluginVersion_VideoCaptureAPIs_intR_intR(api: crate::videoio::VideoCaptureAPIs, version_abi: *mut i32, version_api: *mut i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getCameraBackends(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getStreamBackendPluginVersion_VideoCaptureAPIs_intR_intR(api: crate::videoio::VideoCaptureAPIs, version_abi: *mut i32, version_api: *mut i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getStreamBackends(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getWriterBackendPluginVersion_VideoCaptureAPIs_intR_intR(api: crate::videoio::VideoCaptureAPIs, version_abi: *mut i32, version_api: *mut i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getWriterBackends(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_hasBackend_VideoCaptureAPIs(api: crate::videoio::VideoCaptureAPIs, ocvrs_return: *mut Result<bool>);
		pub fn cv_videoio_registry_isBackendBuiltIn_VideoCaptureAPIs(api: crate::videoio::VideoCaptureAPIs, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_VideoCapture(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_VideoCapture_const_StringR_int(filename: *const c_char, api_preference: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_VideoCapture_const_StringR_int_const_vectorLintGR(filename: *const c_char, api_preference: i32, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_VideoCapture_int_int(index: i32, api_preference: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_VideoCapture_int_int_const_vectorLintGR(index: i32, api_preference: i32, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_open_const_StringR_int(instance: *mut c_void, filename: *const c_char, api_preference: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_open_const_StringR_int_const_vectorLintGR(instance: *mut c_void, filename: *const c_char, api_preference: i32, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_open_int_int(instance: *mut c_void, index: i32, api_preference: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_open_int_int_const_vectorLintGR(instance: *mut c_void, index: i32, api_preference: i32, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_isOpened_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_VideoCapture_grab(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_retrieve_const__OutputArrayR_int(instance: *mut c_void, image: *const c_void, flag: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_read_const__OutputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_set_int_double(instance: *mut c_void, prop_id: i32, value: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_get_const_int(instance: *const c_void, prop_id: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_VideoCapture_getBackendName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_setExceptionMode_bool(instance: *mut c_void, enable: bool, ocvrs_return: *mut Result_void);
		pub fn cv_VideoCapture_getExceptionMode(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_waitAny_const_vectorLVideoCaptureGR_vectorLintGR_int64_t(streams: *const c_void, ready_index: *mut c_void, timeout_ns: i64, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_VideoWriter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_VideoWriter_const_StringR_int_double_Size_bool(filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_VideoWriter_const_StringR_int_int_double_Size_bool(filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_VideoWriter_const_StringR_int_double_const_SizeR_const_vectorLintGR(filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_VideoWriter_const_StringR_int_int_double_const_SizeR_const_vectorLintGR(filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_open_const_StringR_int_double_Size_bool(instance: *mut c_void, filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_open_const_StringR_int_int_double_Size_bool(instance: *mut c_void, filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_open_const_StringR_int_double_const_SizeR_const_vectorLintGR(instance: *mut c_void, filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_open_const_StringR_int_int_double_const_SizeR_const_vectorLintGR(instance: *mut c_void, filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_isOpened_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_VideoWriter_write_const__InputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_VideoWriter_set_int_double(instance: *mut c_void, prop_id: i32, value: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_get_const_int(instance: *const c_void, prop_id: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_VideoWriter_fourcc_char_char_char_char(c1: i8, c2: i8, c3: i8, c4: i8, ocvrs_return: *mut Result<i32>);
		pub fn cv_VideoWriter_getBackendName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
	}
}
#[cfg(ocvrs_has_module_videoio)]
pub use videoio_sys::*;

pub use crate::manual::sys::*;
